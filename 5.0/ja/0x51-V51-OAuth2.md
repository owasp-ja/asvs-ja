# V51 OAuth と OIDC

## 管理目標

OAuth2 は API 認可を委譲するための業界標準となり、OpenID Connect (OIDC) を使用したエンドユーザ認証の基盤にもなっています。OIDC は OAuth2 の上にあるアイデンティティレイヤです。したがって、この章のすべての OAuth2 検証は OIDC にも適用しますが、OAuth2 は OIDC 検証なしでも使用できます。

当初 OAuth はサードパーティのアクセス委譲のために作成されましたが、現在ではセッション管理の代替としてなど、ファーストパーティのソリューションとして使用されることが多くなっています。その複雑さゆえに、過剰なエンジニアリングのリスクをもたらし、新しいセキュリティ上の課題を引き起こす可能性があります。

OAuth と OIDC は Web テクノロジの上に成り立つロジックであるため、他の章の一般的な要件が常に適用され、この章をコンテキストから外して解釈することはできません。
この章では <https://oauth.net/2/> と <https://openid.net/developers/specs/> にある使用に沿った OAuth2 と OIDC の現在のベストプラクティスを説明します。RFC は成熟していると考えられていますが、頻繁に更新されています。したがって、この章の要件を適用する際には、最新バージョンに合わせることが重要です。詳細については参考情報セクションを参照してください。

この領域の複雑さを考えると、安全な OAuth または OIDC ソリューションには、よく知られている業界標準の認可サーバを使用し、推奨されるセキュリティ構成を適用することが極めて重要です。

## V51.1 一般的な OAuth と OIDC セキュリティ

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.1.1** | [追加] トークン (ID トークン、アクセストークン、リフレッシュトークンなど) は本来の目的にのみ使用している。たとえば、ID トークンはクライアントのユーザ認証を証明するためにのみ使用している。 | ✓ | ✓ | ✓ |
| **51.1.2** | [追加] トークンは厳密にそれを必要とするコンポーネントにのみ送信している。たとえば、アクセストークンやリフレッシュトークンがバックエンドでのみ必要な場合はフロントエンドでアクセスできないようにしている。 | ✓ | ✓ | ✓ |
| **51.1.3** | [追加] クライアントは、認可サーバからの値 (認可コードや ID トークンなど) が、同じユーザエージェントセッションとトランザクションによって開始された認可フローから得られた値である場合にのみ、その値を受け入れている。これには、コード交換のための証明鍵 (PKCE) 'code_verifier', 'state' または OIDC 'nonce' などのクライアントが生成したシークレットが推測不可能であり、トランザクションに固有であり、トランザクションが開始されたクライアントとユーザエージェントセッションの両方に安全にバインドされていることが必要である。 | ✓ | ✓ | ✓ |

## V51.2 OAuth 認可サーバ

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.2.1** | [追加] 認可サーバが認可コードを返した場合、そのコードはトークンリクエストに対して一度のみ使用できる。 | ✓ | ✓ | ✓ |
| **51.2.2** | [追加] 認可コードは有効期間を短くしている。最大有効期間は、L1 および L2 アプリケーションで 10 分、L3 アプリケーションで 1 分である。 | ✓ | ✓ | ✓ |
| **51.2.3** | [追加] コードグラントを使用する場合、認可サーバはコード交換のための証明鍵 (PKCE) を要求することで認可コード傍受攻撃を軽減している。認可リクエストでは、認可サーバは有効な 'code_challenge' 値を要求しなければならず、'code_challenge_method' 値 'plain' を受け入れてはいけない。トークンリクエストでは、'code_verifier' パラメータのバリデーションを要求しなければならない。 | ✓ | ✓ | ✓ |
| **51.2.4** | [追加] 認可サーバは、できれば送信者制約リフレッシュトークン (つまり、Demonstrating Proof of Possession (DPoP) または Certificate-Bound Access Tokens (mTLS)) を使用して、パブリッククライアントに対するリフレッシュトークンリプレイ攻撃を軽減している。L1 アプリケーションの場合のみ、代わりにリフレッシュトークンローテーションを使用できる。リフレッシュトークンローテーションを使用する場合、認可サーバが使用後にリフレッシュトークンを無効化し、すでに使用されて無効化されたリフレッシュトークンが提供された場合には、その認可のためのすべてのリフレッシュトークンを失効している。 | ✓ | ✓ | ✓ |
| **51.2.5** | [追加] 特定のクライアントに対して、認可サーバはこのクライアントが使用する必要があるグラントの使用のみを許可している。'token' (暗黙的フロー) と 'password' (リソースオーナーのパスワードクレデンシャルフロー) のグラントはもはや使用すべきではないことに注意する。 | ✓ | ✓ | ✓ |
| **51.2.6** | [追加] 認可サーバは、正確な文字列比較を使用して、事前登録された URI のクライアント固有の許可リストに基づいて、リダイレクト URI を検証している。 | ✓ | ✓ | ✓ |
| **51.2.7** | [追加] コンフィデンシャルクライアントは、トークンリクエスト、プッシュ認可リクエスト (PAR)、トークン失効リクエスト、トークン確認リクエストなどのクライアントから認可済みサーバーへのバックチャネルリクエストに対して認証されている。 | ✓ | ✓ | ✓ |
| **51.2.8** | [追加] 認可サーバ設定では、必要なスコープのみを OAuth クライアントに割り当てている。 | ✓ | ✓ | ✓ |
| **51.2.9** | [追加] 'code' グラントタイプは常にプッシュ認可リクエスト (PAR) と一緒に使用されている。 | | | ✓ |
| **51.2.10** | [追加] クライアントはコンフィデンシャルであり、認可サーバは強力なクライアント認証方法 (公開鍵暗号に基づき、リプレイ攻撃に耐性がある)、すなわち 'mTLS' または 'private-key-jwt' の使用を要求する。 | | | ✓ |
| **51.2.11** | [追加] 認可サーバは、mTLS 証明書バインディングまたは Demonstration of Proof of Possession (DPoP) のいずれかを使用して、送信者制約 (Proof-of-Posession) アクセストークンのみを発行する。 | | | ✓ |
| **51.2.12** | [追加] 特定のクライアントに対して、認可サーバはこのクライアントが使用する必要がある 'response_mode' 値のみを許可している。たとえば認可サーバがこの値を期待値と検証したり、プッシュ認可リクエスト (PAR) や JWT で保護された認可リクエスト (JAR) を使用している。 | ✓ | ✓ | ✓ |
| **51.2.13** | [追加] リフレッシュトークンは、スライディングリフレッシュトークン有効期限が適用されている場合も含め、絶対的な有効期限を持つ。 | ✓ | ✓ | ✓ |
| **51.2.14** | [修正, 3.5.1 からマージ] リフレッシュトークンとリファレンスアクセストークンは認可されたユーザによって失効されることができる。これは、認可サーバのユーザインタフェースを使用するか、失効に認可サーバ API を使用しているクライアントによって実施できる。 | | ✓ | ✓ |
| **51.2.15** | [追加] サーバサイドクライアント (エンドユーザデバイス上で実行されない) では、認可サーバは 'authorization_details' パラメータ値がクライアントバックエンドからのものであり、ユーザがそれを改竄していないことを確保している。たとえば、プッシュ認可リクエスト (PAR) または JWT で保護された認可リクエスト (JAR) の使用を要求する。 | | | ✓ |

## V51.3 OAuth クライアント

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.3.1** | [追加] OAuth クライアントが複数の認可サーバとやり取りできる場合、ミックスアップ攻撃に対して防御している。たとえば、認可サーバが 'iss' パラメータ値を返し、認可レスポンスとトークンレスポンスでそれを検証することを要求できる。 | ✓ | ✓ | ✓ |
| **51.3.2** | [追加] コードフローが使用される場合、OAuth クライアントはコード交換のための証明鍵 (PKCE) 機能を使用するか、認可リクエストで送信された state パラメータをチェックすることで、トークンリクエストをトリガーするクロスサイトリクエストフォージェリ (CSRF) 攻撃から保護している。 | ✓ | ✓ | ✓ |
| **51.3.3** | [追加] OAuth クライアントは、認可サーバへのリクエストで必要なスコープ (またはその他の認可パラメータ) のみをリクエストしている。 | ✓ | ✓ | ✓ |

## V51.4 OAuth リソースサーバ

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.4.1** | [追加] リソースサーバは、OAuth 2 の相互 TLS または OAuth 2 Demonstration of Proof of Possession (DPoP) のいずれかの送信者制約のあるアクセストークンを要求することで、盗まれたアクセストークンの使用やアクセストークンのリプレイを (認可されていない第三者から) 防止する。 | | | ✓ |
| **51.4.2** | [追加] リソースサーバは、アクセストークンがそのサーバ (オーディエンス) で使用されることを意図していることを確保している。JWT フォーマットのアクセストークンでは、またはトークンイントロスペクションから JWT を使用する場合には、これは 'aud' クレームをチェックすることで行うことができる。 | ✓ | ✓ | ✓ |
| **51.4.3** | [追加] アクセストークンはリソースサーバまたはリソース上の特定のリソースとアクションに制限されている。すべてのリソースサーバは、リクエストごとに、そのリクエストとともに送信されるアクセストークンが特定のリソース上の特定のアクションに使用されることを意図したものであるかどうかを検証する義務がある。そうでない場合、リソースサーバはそれぞれのリクエストへの対処を拒否しなければならない。 | ✓ | ✓ | ✓ |
| **51.4.4** | [追加] アクセス制御の決定がアクセストークン (JWT または関連するトークンイントロスペクションレスポンス) から一意のユーザを識別する必要がある場合、リソースサーバは他のユーザーに再割り当てできないクレームからユーザを識別する。通常、これは 'iss' と 'sub' のクレームの組み合わせを使用することを意味する。 | ✓ | ✓ | ✓ |

## V51.5 OIDC クライアント

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.5.1** | [追加] クライアント (relying party) は ID トークンのリプレイ攻撃を軽減している。たとえば、ID トークンの 'nonce' クレームが OpenID プロバイダへの認証リクエスト (OAuth2 では認可サーバに送信される認可リクエストと呼ばれる) で送信された 'nonce' 値と一致することを確認している。 | ✓ | ✓ | ✓ |
| **51.5.2** | [追加] クライアントは ID トークンクレーム (通常は 'sub' クレーム) からユーザを一意に識別するが、(ID プロバイダのスコープでは) 他のユーザに再割り当てできない。 | ✓ | ✓ | ✓ |
| **51.5.3** | [追加] クライアントは悪意のある認可サーバが認可サーバメタデータを通じて別の認可サーバになりすまそうとする試みを拒否する。認可サーバメタデータの発行者 URL が、クライアントが期待する事前設定された発行者 URL と正確に一致しない場合、クライアントは認可サーバメタデータを拒否しなければならない。 | ✓ | ✓ | ✓ |
| **51.5.4** | [追加] クライアントは、トークンの 'aud' クレームがクライアントの 'client_id' 値と等しいことをチェックすることで、ID トークンがそのクライアント (オーディエンス) のために使用されることを意図していることを検証している。 | ✓ | ✓ | ✓ |

## V51.5 OIDC OpenID プロバイダ

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.6.1** | [追加] OpenID プロバイダはレスポンスモードに 'code', 'ciba', 'id-token', 'id-token code' の値のみを許可している。'code' は 'id-token code' (OIDC ハイブリッドフロー) よりも優先されること、'token' (任意の暗黙的フロー) は使用すべきではないことに注意する。 | ✓ | ✓ | ✓ |

## 用語

この章では OAuth 2.0 RFC 6749 で定義されている「アクセストークン」、「リフレッシュトークン」、「クライアント」、「認可サーバ」、「リソースオーナー」、「リソースサーバ」という用語を使用します。そのため、この章では以下の用語を定義します。

### アクセストークン (Access tokens)

アクセストークンは抽象化を提供し、さまざまな認可構成要素 (ユーザ名とパスワード、アサーションなど) をリソースサーバが理解できる単一のトークンに置き換えます。この抽象化により、短期間有効なアクセストークンを発行可能になり、リソースサーバがさまざまな認証スキームを理解する必要がなくなります。

### リフレッシュトークン (Refresh tokens)

リフレッシュトークンはアクセストークンを取得するために使用されるクレデンシャルです。これらは認可サーバによってクライアントに発行され、現在のアクセストークンが無効や期限切れになったときに新しいアクセストークンを取得したり、同一またはより狭い範囲の追加アクセストークンを取得するために使用されます (アクセストークンはリソースオーナーによって認可されるよりも短い有効期間と少ないパーミッションを持つことがあります)。

### クライアント (Client)

クライアントは一般的にリソースオーナーの代わりに、その認可を得て、保護されたリソースリクエストを行うアプリケーションを指します。「クライアント」という用語は特定の実装特性 (たとえば、アプリケーションがサーバ、デスクトップ、またはその他のデバイス上で実行されるかどうか) を意味するものではありません。

### 認可サーバ (Authorization Server, AS)

認可サーバは、リソースオーナーの認証に成功し、認可を取得した後、クライアントにアクセストークンを発行するサーバまたはエンティティを指します。

### リソースオーナー (Resource Owner, RO)

リソースオーナーは保護されたリソースへのアクセスを許可できるエンティティを指します。リソースオーナーが個人である場合、それはエンドユーザと呼ばれます。

### リソースサーバ (Resource Server, RS)

リソースサーバは保護されたリソースをホストするサーバを指し、保護されたリソースへのアクセストークンを使用したリクエストを受け付けて応答できます。

## 参考情報

OAuth について詳しくは以下の情報を参照してください。

* [oauth.net](https://oauth.net/)
* [OWASP Cheat Sheet: OAuth 2.0 Protocol Cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/OAuth2_Cheat_Sheet.html)

ASVS の OAuth 関連の要件については、以下の発行済みおよびドラフト状態の RFC が使用されます。

* [RFC6749 The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)
* [RFC6750 The OAuth 2.0 Authorization Framework: Bearer Token Usage](https://datatracker.ietf.org/doc/html/rfc6750)
* [RFC6819 OAuth 2.0 Threat Model and Security Considerations](https://datatracker.ietf.org/doc/html/rfc6819)
* [RFC7636 Proof Key for Code Exchange by OAuth Public Clients](https://datatracker.ietf.org/doc/html/rfc7636)
* [RFC9068 JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens](https://datatracker.ietf.org/doc/html/rfc9068)
* [RFC8628 OAuth 2.0 Device Authorization Grant](https://datatracker.ietf.org/doc/html/rfc8628)
* [RFC8707 Resource Indicators for OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc8707)
* [RFC9126 OAuth 2.0 Pushed Authorization Requests](https://datatracker.ietf.org/doc/html/rfc9126)
* [RFC9207 OAuth 2.0 Authorization Server Issuer Identification](https://datatracker.ietf.org/doc/html/rfc9207)
* [RFC9396 OAuth 2.0 Rich Authorization Requests](https://datatracker.ietf.org/doc/html/rfc9396)
* [RFC9449 OAuth 2.0 Demonstrating Proof of Possession (DPoP)](https://datatracker.ietf.org/doc/html/rfc9449)
* [draft OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)<!-- recheck on release -->
* [draft OAuth 2.0 for Browser-Based Applications](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps)<!-- recheck on release -->
* [draft The OAuth 2.1 Authorization Framework](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11)<!-- recheck on release -->

OpenID Connect について詳しくは以下の情報を参照してください。

* [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)
* [FAPI 2.0 Security Profile](https://openid.bitbucket.io/fapi/fapi-2_0-security-profile.html)<!-- recheck on release -->
