# V51 OAuth と OIDC

この章では、すべての OAuth 実装者向けに [RFC 6750](https://www.rfc-editor.org/info/rfc6750) および [6749](https://www.rfc-editor.org/info/rfc6749) から導き出された OAuth 2.0 の [現在のセキュリティのベストプラクティス](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#name-best-practices) を説明し、要約します。OAuth は API 保護の標準となり、OpenID Connect を使用したフェデレーションログインの基礎になりました。OpenID Connect 1.0 は OAuth 2.0 プロトコル上のシンプルな ID レイヤです。これによってクライアントは、認可サーバによって実行される認証に基づいてエンドユーザの身元を検証したり、エンドユーザに関する基本的なプロフィール情報を相互運用可能な REST ライクな方法で取得できるようになります。

OAuth プロセスにはさまざまなペルソナが存在します。詳細については以下の用語セクションで説明します。あるペルソナの要件が他のペルソナに関連しない可能性があるため、この章の要件はそれらのペルソナに基づいて構成されています。

## V51.1 一般的な OAuth と OIDC セキュリティ

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.1.1** | [追加] トークン (ID トークン、アクセストークン、リフレッシュトークンなど) は本来の目的にのみ使用している。たとえば、ID トークンはクライアントのユーザ認証を証明するためにのみ使用している。 | ✓ | ✓ | ✓ |
| **51.1.2** | [追加] トークンは厳密にそれを必要とするコンポーネントにのみ送信している。たとえば、アクセストークンやリフレッシュトークンがバックエンドでのみ必要な場合はフロントエンドでアクセスできないようにしている。 | ✓ | ✓ | ✓ |

## V51.2 OAuth 認可サーバ

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.2.1** | [追加] 認可サーバが認可コードを返した場合、そのコードはトークンリクエストに対して一度のみ使用でき、有効期限は最長で 10 分間までである。 | ✓ | ✓ | ✓ |
| **51.2.2** | [追加] 認可レスポンスへの認可コードのリプレイは PKCE フローを使用するか、OpenID Connect の「nonce」パラメータと ID Token のそれぞれの Claim を使用することで防止している。PKCE チャレンジや OpenID Connect の「nonce」はトランザクション固有であり、トランザクションが開始されたクライアントとユーザエージェントに安全にバインドされなければならない。 | ✓ | ✓ | ✓ |
| **51.2.3** | [追加] コードグラントを使用する場合、認可サーバは PKCE を要求することで認可コード傍受攻撃を軽減している。認可リクエストでは、認可サーバは有効な code_challenge 値を要求しなければならず、code_challenge_method 'plain' を受け入れてはいけない。トークンリクエストでは、"code_verifier" パラメータのバリデーションを要求しなければならない。 | ✓ | ✓ | ✓ |
| **51.2.4** | [追加] 認可サーバは (L1, L2) リフレッシュトークンローテーションまたは (L1, L2, L3) Demonstrating Proof of Possession (DPoP) または Certificate-Bound Access Tokens (mTLS) を使用した送信者制約リフレッシュトークンを使用して、パブリッククライアントに対するリフレッシュトークンリプレイ攻撃を軽減している。リフレッシュトークンローテーションを使用する場合、認可サーバが使用後にリフレッシュトークンを無効化し、すでに使用されて無効化されたリフレッシュトークンが提供された場合には、その認可のためのすべてのリフレッシュトークンを失効している。 | ✓ | ✓ | ✓ |
| **51.2.5** | [追加] 特定のクライアントに対して、認可サーバはこのクライアントが使用する必要があるグラントの使用のみを許可している。'token' (暗黙的フロー) と 'password' (リソースオーナーのパスワードクレデンシャルフロー) のグラントはもはや使用すべきではないことに注意する。 | ✓ | ✓ | ✓ |
| **51.2.6** | [追加] 認可サーバは、正確な文字列比較を使用して、事前登録された URI のクライアント固有の許可リストに基づいて、リダイレクト URI を検証している。 | ✓ | ✓ | ✓ |
| **51.2.7** | [追加] コンフィデンシャルクライアントは、トークンリクエスト、PAR リクエスト、トークン失効リクエスト、トークン確認リクエストなどのクライアントから認可済みサーバーへのバックチャネルリクエストに対して認証されている。 | ✓ | ✓ | ✓ |
| **51.2.8** | [追加] 認可サーバ設定では、必要なスコープのみを OAuth クライアントに割り当てている。 | ✓ | ✓ | ✓ |
| **51.2.9** | [追加] 'code' グラントタイプは常にプッシュ認可リクエスト (PAR) と一緒に使用されている。 | | | ✓ |
| **51.2.10** | [追加] クライアントはコンフィデンシャルであり、認可サーバは強力なクライアント認証方法 (公開鍵暗号に基づき、リプレイ攻撃に耐性がある)、すなわち 'mTLS' または 'private-key-jwt' の使用を要求する。 | | | ✓ |
| **51.2.11** | [追加] 認可サーバは、mTLS 証明書バインディングまたは Demonstration of Proof of Possession (DPoP) のいずれかを使用して、送信者制約 (Proof-of-Posession) アクセストークンのみを発行する。 | | | ✓ |
| **51.2.12** | [追加] 特定のクライアントの場合、認可サーバはこのクライアントが使用する必要がある 'response_mode' 値のみを許可する。 | ✓ | ✓ | ✓ |
| **51.2.13** | [追加] リフレッシュトークンは、スライディングリフレッシュトークン有効期限が適用されている場合も含め、絶対的な有効期限を持つ。 | ✓ | ✓ | ✓ |
| **51.2.14** | [追加] リフレッシュトークンとリファレンスアクセストークンは認可されたユーザによって失効されることができる。これは、認可サーバのユーザインタフェースを使用するか、失効に認可サーバ API を使用しているクライアントによって実施できる。 | ✓ | ✓ |

## V51.3 OAuth クライアント

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.3.1** | [追加] OAuth クライアントが複数の認可サーバとやり取りできる場合、ミックスアップ攻撃に対して防御している。たとえば、認可サーバが「iss」パラメータ値を返し、認可レスポンスとトークンレスポンスでそれを検証することを要求できる。 | ✓ | ✓ | ✓ |
| **51.3.2** | [追加] クライアントは PKCE フローを使用するか、あるいは OpenID Connect の「nonce」パラメータと ID Token のそれぞれの Claim を使用している。 | ✓ | ✓ | ✓ |
| **51.3.3** | [追加] クライアントは「scope」パラメータと「resource」パラメータを利用して、それぞれアクセスしたいリソースサーバを決定している。 | ✓ | ✓ | ✓ |
| **51.3.4** | [追加] クライアントは「scope」パラメータと「authorization_details」パラメータを利用して、アクセストークンが制限される関連リソースとアクションを決定している。 | ✓ | ✓ | ✓ |
| **51.3.5** | [追加] コードフローが使用される場合、OAuth クライアントは PKCE 機能を使用するか、認可リクエストで送信された state パラメータをチェックすることで、トークンリクエストをトリガーする CSRF 攻撃から保護している。 | ✓ | ✓ | ✓ |
| **51.3.6** | [追加] OAuth クライアントは、認可サーバへのリクエストで必要なスコープ (またはその他の認可パラメータ) のみをリクエストしている。 | ✓ | ✓ | ✓ |

## V51.4 OAuth リソースサーバ

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.4.1** | [追加] リソースサーバは、OAuth 2 の相互 TLS または OAuth 2 Demonstration of Proof of Possession (DPoP) のいずれかの送信者制約のあるアクセストークンを要求することで、盗まれたアクセストークンの使用やアクセストークンのリプレイを (認可されていない第三者から) 防止する。 | | | ✓ |
| **51.4.2** | [追加] アクセストークンは特定のリソースサーバ、できれば単一のリソースサーバに制限されている (利用者制限)。すべてのリソースサーバは、リクエストごとに、そのリクエストとともに送信されるアクセストークンがその特定のリソースサーバに使用されることを意図したものであるかどうかを検証する義務がある。そうでない場合、リソースサーバはそれぞれのリクエストへの対処を拒否しなければならない。 | ✓ | ✓ | ✓ |
| **51.4.3** | [追加] アクセストークンはリソースサーバまたはリソース上の特定のリソースとアクションに制限されている。すべてのリソースサーバは、リクエストごとに、そのリクエストとともに送信されるアクセストークンが特定のリソース上の特定のアクションに使用されることを意図したものであるかどうかを検証する義務がある。そうでない場合、リソースサーバはそれぞれのリクエストへの対処を拒否しなければならない。 | ✓ | ✓ | ✓ |
| **51.4.4** | [追加] アクセス制御の決定がアクセストークン (JWT または関連するトークンイントロスペクションレスポンス) から一意のユーザを識別する必要がある場合、リソースサーバは他のユーザーに再割り当てできないクレームからユーザを識別する。通常、これは 'iss' と 'sub' のクレームの組み合わせを使用することを意味する。 | ✓ | ✓ | ✓ |

## V51.5 OIDC クライアント

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.5.1** | [追加] クライアント (Relying Party) は ID トークンのリプレイ攻撃を軽減している。たとえば、ID トークンの nonce クレームが OpenID プロバイダへの認証リクエスト (OAuth2 では認可サーバに送信される認可リクエストと呼ばれる) で送信された nonce 値と一致することを確認している。 | ✓ | ✓ | ✓ |
| **51.5.2** | [追加] クライアントは ID トークンクレーム (通常は「sub」クレーム) からユーザを一意に識別するが、(ID プロバイダのスコープでは) 他のユーザに再割り当てできない。 | ✓ | ✓ | ✓ |

## V51.5 OIDC OpenID プロバイダ

| # | 説明 | L1 | L2 | L3 |
| :---: | :--- | :---: | :---: | :---: |
| **51.6.1** | [追加] OpenID プロバイダはレスポンスモードに 'code', 'ciba', 'id-token', 'id-token code' の値のみを許可している。'code' は 'id-token code' (OIDC ハイブリッドフロー) よりも優先されること、'token' (任意の暗黙的フロー) は使用すべきではないことに注意する。 | ✓ | ✓ | ✓ |

## 用語

この章では OAuth 2.0 RFC 6749 で定義されている「アクセストークン」、「リフレッシュトークン」、「クライアント」、「認可サーバ」、「リソースオーナー」、「リソースサーバ」という用語を使用します。そのため、この章では以下の用語を定義します。

### アクセストークン (Access tokens)

アクセストークンは抽象化を提供し、さまざまな認可構成要素 (ユーザ名とパスワード、アサーションなど) をリソースサーバが理解できる単一のトークンに置き換えます。この抽象化により、短期間有効なアクセストークンを発行可能になり、リソースサーバがさまざまな認証スキームを理解する必要がなくなります。

### リフレッシュトークン (Refresh tokens)

リフレッシュトークンはアクセストークンを取得するために使用されるクレデンシャルです。これらは認可サーバによってクライアントに発行され、現在のアクセストークンが無効や期限切れになったときに新しいアクセストークンを取得したり、同一またはより狭い範囲の追加アクセストークンを取得するために使用されます (アクセストークンはリソースオーナーによって認可されるよりも短い有効期間と少ないパーミッションを持つことがあります)。

### クライアント (Client)

クライアントは一般的にリソースオーナーの代わりに、その認可を得て、保護されたリソースリクエストを行うアプリケーションを指します。「クライアント」という用語は特定の実装特性 (たとえば、アプリケーションがサーバ、デスクトップ、またはその他のデバイス上で実行されるかどうか) を意味するものではありません。

### 認可サーバ (Authorization Server, AS)

認可サーバは、リソースオーナーの認証に成功し、認可を取得した後、クライアントにアクセストークンを発行するサーバまたはエンティティを指します。

### リソースオーナー (Resource Owner, RO)

リソースオーナーは保護されたリソースへのアクセスを許可できるエンティティを指します。リソースオーナーが個人である場合、それはエンドユーザと呼ばれます。

### リソースサーバ (Resource Server, RS)

リソースサーバは保護されたリソースをホストするサーバを指し、保護されたリソースへのアクセストークンを使用したリクエストを受け付けて応答できます。

## OAuth 2.0 の基本

OpenID Connect フローでは、「nonce」パラメータにより CSRF 保護を提供します。さもなければ、ユーザエージェントに安全にバインドされ、「state」パラメータで届けられるワンタイムユーザ CSRF トークンを CSRF 保護に使用しなければなりません。

### PKCE (Proof Key for Code Exchange Mechanism / Authorization Code Grant) - コード交換メカニズム/認可コードグラントのための証明鍵

認可コードグラントを利用する OAuth 2.0 パブリッククライアントは認可コード横取り攻撃の影響を受けやすくなります。Proof Key for Code Exchange (PKCE, 「ピクシー (pixy)」と発音) は認可コード横取り攻撃の脅威を軽減するために使用される技術です。

元来、PKCE はネイティブアプリのセキュリティ保護に特化して使用されることを意図していましたが、その後 OAuth 機能として導入されるようになりました。これは認可コードインジェクション攻撃から保護するだけでなく、パブリッククライアント用に作成された認可コードも保護します。PKCE により攻撃者は code_verifier の知識がなければ、認可サーバのトークンエンドポイントで盗まれた認可コードを引き換えることができなくなります。

PKCE チャレンジや OpenID Connect の「nonce」はトランザクション固有であり、トランザクションが開始されたクライアントとユーザエージェントに安全にバインドされなければなりません。

### トークンリプレイの防止

トークンリプレイ攻撃を防ぐことは、OAuth 2.0 を使用および実装する上で非常に重要です。

### アクセストークンの権限制限

トークンの権限を制限することで、クライアントに特定のリソースへの適切なアクセスが付与されます。

### リソースオーナーのパスワードクレデンシャルグラント

このグラントタイプは認可サーバだけでなく、さまざまな場所でクレデンシャルを漏洩する可能性があります。リソースオーナーのパスワードクレデンシャルグラントを二要素認証、暗号化クレデンシャル (WebCrypto, WebAuthn など) での認証、複数のステップを必要とする認証プロセスに適応することは困難または不可能になる可能性があります。このグラントタイプはセキュリティ上の懸念があるため、一般的には推奨されません。代わりに、PKCE で認可コードグラントを使用してください。このグラントタイプは OAuth 2.1 使用では省略されています。

## OAuth 2.0 参考情報

詳しくは以下の情報を参照してください。

* RFC 6749 - The OAuth 2.0 Authorization Framework: <https://www.rfc-editor.org/info/rfc6749>
* RFC 6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage: <https://www.rfc-editor.org/info/rfc6750>
* OAuth 2.0 Best Practices: <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#name-best-practices>
* Mix-up attacks: <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-18#mix_up>
* RFC9207 - OAuth 2.0 Authorization Server Issuer Identifier in Authorization Response: <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-iss-auth-resp-00>
* Other Countermeasures for Mix-up attacks: <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-18#section-2.1-6>
