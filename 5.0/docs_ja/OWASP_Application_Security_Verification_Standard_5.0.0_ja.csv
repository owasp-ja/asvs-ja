chapter_id,chapter_name,section_id,section_name,req_id,req_description,L
V1,エンコーディングとサニタイゼーション,V1.1,エンコーディングおよびサニタイゼーションアーキテクチャ,V1.1.1,入力は一度だけ標準形式にデコードまたはアンエスケープされ、その形式でエンコードされたデータが期待される場合にのみデコードされ、これは入力をさらに処理する前に行われる。たとえば、入力バリデーションやサニタイゼーションの後には実行されない。,2
V1,エンコーディングとサニタイゼーション,V1.1,エンコーディングおよびサニタイゼーションアーキテクチャ,V1.1.2,アプリケーションはそれが意図されているインタプリタまたはインタプリタ自体によって使用される前の最終ステップとして、出力エンコーディングおよびエスケープを実行する。,2
V1,エンコーディングとサニタイゼーション,V1.2,インジェクション防御,V1.2.1,HTTP レスポンス、HTML ドキュメント、XML ドキュメントの出力エンコーディングは、メッセージやドキュメント構造の変更を避けるために、HTML 要素、HTML 属性、HTML コメント、CSS、HTTP ヘッダフィールドに関連する文字をエンコードするなど、要求されるコンテキストに関連している。,1
V1,エンコーディングとサニタイゼーション,V1.2,インジェクション防御,V1.2.2,URL を動的に構築する場合、信頼できないデータはそのコンテキストに応じてエンコードされている (例: クエリやパスパラメータの URL エンコーディングや base64url エンコーディング)。安全な URL プロトコルのみが許可されるようにしている (例: javascript: や data: を許可しない)。,1
V1,エンコーディングとサニタイゼーション,V1.2,インジェクション防御,V1.2.3,出力エンコーディングまたはエスケープは、JavaScript コンテンツ (JSON を含む) を動的に構築するときに使用され、メッセージやドキュメント構造の変更を回避している (JavaScript および JSON インジェクションを回避するため)。,1
V1,エンコーディングとサニタイゼーション,V1.2,インジェクション防御,V1.2.4,"データ選択またはデータベースクエリ (SQL, HQL, NoSQL, Cypherなど) がパラメータ化クエリ、ORM、エンティティフレームワークもしくは他の方法により保護されており、SQL インジェクションや他のデータベースインジェクション攻撃の影響を受けない。これはストアドプロシージャを記述する際にも関係する。",1
V1,エンコーディングとサニタイゼーション,V1.2,インジェクション防御,V1.2.5,アプリケーションが OS コマンドインジェクションに対して保護していること、およびオペレーティングシステムコールがパラメータ化された OS クエリを使用するか、コンテキストに応じたコマンドライン出力エンコーディングを使用する。,1
V1,エンコーディングとサニタイゼーション,V1.2,インジェクション防御,V1.2.6,アプリケーションが LDAP インジェクション脆弱性に対して保護している、または LDAP インジェクションを防ぐために特定のセキュリティ管理策が実装されている。,2
V1,エンコーディングとサニタイゼーション,V1.2,インジェクション防御,V1.2.7,アプリケーションは、クエリパラメータ化やコンパイル済みクエリを使用することで、XPath インジェクション攻撃から保護されている。,2
V1,エンコーディングとサニタイゼーション,V1.2,インジェクション防御,V1.2.8,"LaTeX プロセッサは (""--shell-escape"" フラグを使用しないなど) 安全に構成されており、LaTeX インジェクション攻撃を防ぐためにコマンドの許可リストを使用している。",2
V1,エンコーディングとサニタイゼーション,V1.2,インジェクション防御,V1.2.9,アプリケーションは正規表現内の特殊文字をエスケープ (通常はバックスラッシュを使用) し、メタ文字として誤って解釈されることを防いでいる。,2
V1,エンコーディングとサニタイゼーション,V1.2,インジェクション防御,V1.2.10,"アプリケーションが CSV インジェクションや数式インジェクションから保護されている。アプリケーションは CSV コンテンツをエクスポートする際に RFC 4180 セクション 2.6 および 2.7 で定義されているエスケープ規則に従う必要がある。さらに、CSV やその他のスプレッドシート形式 (XLS, XLSX, ODF など) をエクスポートする際に、特殊文字 ('=', '+', '-', '@', '\t' (タブ), '\0' (ヌル文字) など) がフィールド値の最初の文字として現れる場合、シングルクォートでエスケープする必要がある。",3
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.1,WYSIWYG エディタなどから取得した信頼できない HTML 入力はすべて、よく知られた安全な HTML サニタイゼーションライブラリもしくはフレームワークの機能を使用してサニタイズされている。,1
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.2,アプリケーションが eval() や他の Spring Expression Language (SpEL) などの動的コード実行機能を使用しない。代替手段がない場合は、実行前に含まれるユーザ入力をサニタイズする必要がある。,1
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.3,潜在的に危険なコンテキストに渡されるデータは、事前にサニタイズして、このコンテキストにとって安全な文字だけを許可したり、長すぎる入力を切り詰めるなどの安全対策を実施している。,2
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.4,ユーザが提供する Scalable Vector Graphics (SVG) スクリプト可能コンテンツは、スクリプトや foreignObject を含まないなど、アプリケーションにとって安全なタグや属性 (図形描画など) のみを含むように検証またはサニタイズされている。,2
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.5,アプリケーションは、マークダウン、CSS や XSL スタイルシート、BBCode などのユーザが提供するスクリプト可能コンテンツまたは式テンプレート言語コンテンツをサニタイズまたは無効化している。,2
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.6,アプリケーションは、信頼できないデータをプロトコル、ドメイン、パス、ポートの許可リストに照らして検証し、そのデータを使用して別のサービスを呼び出す前に潜在的に危険な文字をサニタイズすることで、サーバサイドリクエストフォージェリ (SSRF) 攻撃から保護している。,2
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.7,アプリケーションは信頼できない入力に基づくテンプレートの作成を許可しないことで、テンプレートインジェクション攻撃から保護している。代替手段がない場合、テンプレート作成中に動的に含まれるすべての信頼できない入力はサニタイズまたは厳密に確認する必要がある。,2
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.8,アプリケーションは Java Naming and Directory Interface (JNDI) クエリで使用する前に信頼できない入力を適切にサニタイズし、JNDI を安全に構成して JNDI インジェクション攻撃を防いでいる。,2
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.9,アプリケーションは memcache に送信する前にコンテンツをサニタイズし、インジェクション攻撃を防いでいる。,2
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.10,使用時に、予期しないあるいは悪意のある方法で解決される可能性のあるフォーマット文字列は、処理される前にサニタイズされている。,2
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.11,SMTP インジェクションや IMAP インジェクションから保護するため、アプリケーションがメールシステムに渡す前にユーザ入力をサニタイズしている。,2
V1,エンコーディングとサニタイゼーション,V1.3,サニタイゼーション,V1.3.12,正規表現に指数関数的なバックトラッキングを引き起こす要素がないことを検証している。また、信頼できない入力をサニタイズし、ReDoS 攻撃や Runaway Regex 攻撃を軽減している。,3
V1,エンコーディングとサニタイゼーション,V1.4,メモリ、文字列、アンマネージドコード,V1.4.1,アプリケーションはメモリセーフな文字列、安全なメモリコピーおよびポインタ演算を使用して、スタック、バッファ、ヒープのオーバーフローを検出または防止する。,2
V1,エンコーディングとサニタイゼーション,V1.4,メモリ、文字列、アンマネージドコード,V1.4.2,整数オーバーフローを防ぐために符号、範囲、および入力のバリデーション技法が使用されている。,2
V1,エンコーディングとサニタイゼーション,V1.4,メモリ、文字列、アンマネージドコード,V1.4.3,動的に割り当てられたメモリとリソースが解放され、解放されたメモリへの参照やポインタが削除されるか null に設定されて、ダングリングポインタや use-after-free 脆弱性を防いでいる。,2
V1,エンコーディングとサニタイゼーション,V1.5,安全なデシリアライゼーション,V1.5.1,"アプリケーションが XML パーサーを制限的な構成を使用するよう構成し、XML 外部エンティティ (XML eXternal Entity, XXE) 攻撃を防止するために外部エンティティの解決などの安全でない機能を無効にする。",1
V1,エンコーディングとサニタイゼーション,V1.5,安全なデシリアライゼーション,V1.5.2,信頼できないデータのデシリアライゼーションでは、オブジェクトタイプの許可リストを使用したり、クライアント定義のオブジェクトタイプを制限するなど、安全な入力処理を強制してデシリアライゼーション攻撃を防いでいる。明示的に安全でないと定義されているデシリアライゼーションメカニズムは信頼できない入力では使用してはいけない。,2
V1,エンコーディングとサニタイゼーション,V1.5,安全なデシリアライゼーション,V1.5.3,JSON 相互運用性の脆弱性や、さまざまな URI やファイルの解析動作がリモートファイルインクルージョン (RFI) やサーバサイドリクエストフォージェリ (SSRF) 攻撃で悪用されるような問題を回避するために、同じデータ型に対してアプリケーションで使用されるさまざまなパーサー (JSON パーサー、XML パーサー、URL パーサーなど) は一貫した方法で解析を実行し、同じエンコードメカニズムを使用する。,3
V2,バリデーションとビジネスロジック,V2.1,バリデーションとビジネスロジックドキュメント,V2.1.1,アプリケーションのドキュメントには、期待される構造に対するデータ項目の妥当性をチェックする方法についての入力バリデーションルールを定義している。これは、クレジットカード番号、電子メールアドレス、電話番号のような一般的なデータ形式のこともあれば、内部データ形式のこともある。,1
V2,バリデーションとビジネスロジック,V2.1,バリデーションとビジネスロジックドキュメント,V2.1.2,アプリケーションのドキュメントには、地区と郵便番号が一致することをチェックするなど、組み合わされたデータ項目の論理的およびコンテキスト的な一貫性を検証する方法を定義している。,2
V2,バリデーションとビジネスロジック,V2.1,バリデーションとビジネスロジックドキュメント,V2.1.3,ビジネスロジックの制限とバリデーションに対する期待は、ユーザーごと、およびアプリケーション全体にわたって文書化されている。,2
V2,バリデーションとビジネスロジック,V2.2,入力バリデーション,V2.2.1,入力はその入力に対するビジネスまたは機能上の期待を満たすことを検証されている。これは、許容される値、パターン、範囲のリストに対する肯定的なバリデーションを使用するか、あらかじめ定義されたルールに従って、期待される構造および論理的限界と入力との比較に基づく必要がある。L1 では、これは特定のビジネスまたはセキュリティ上の意思決定に使用される入力に焦点を当てることができる。L2 以上では、これはすべての入力に適用する必要がある。,1
V2,バリデーションとビジネスロジック,V2.2,入力バリデーション,V2.2.2,アプリケーションは信頼できるサービスレイヤで入力バリデーションを実行するように設計されている。クライアントサイドのバリエーションはユーザービリティを向上するため推奨されるが、セキュリティコントロールとしては依存してはいけない。,1
V2,バリデーションとビジネスロジック,V2.2,入力バリデーション,V2.2.3,アプリケーションは、関連するデータ項目の組み合わせが事前に定義されたルールに従って妥当であることを確保している。,2
V2,バリデーションとビジネスロジック,V2.3,ビジネスロジックのセキュリティ,V2.3.1,アプリケーションは同じユーザのビジネスロジックフローを期待した正しい手順通り、省略せずに処理する。,1
V2,バリデーションとビジネスロジック,V2.3,ビジネスロジックのセキュリティ,V2.3.2,ビジネスロジックの制限はアプリケーションのドキュメントに従って実装され、ビジネスロジックの欠陥が悪用されることを避けている。,2
V2,バリデーションとビジネスロジック,V2.3,ビジネスロジックのセキュリティ,V2.3.3,トランザクションはビジネスロジックレベルで使用されてビジネスロジックオペレーション全体が成功するか、以前の正しい状態にロールバックされる。,2
V2,バリデーションとビジネスロジック,V2.3,ビジネスロジックのセキュリティ,V2.3.4,ビジネスロジックレベルのロックメカニズムを使用して、アプリケーションのロジックを操作することで、数量に限りのあるリソース (劇場の座席や配送枠など) が二重に予約されないようにしている。,2
V2,バリデーションとビジネスロジック,V2.3,ビジネスロジックのセキュリティ,V2.3.5,価値の高いロジックフローは複数ユーザの承認を必要とし、不正なアクションや偶発的なアクションを防いでいる。これには、多額の送金、契約の承認、機密情報へのアクセス、製造における安全のオーバーライドなどが含まれるが、これらに限定されない。,3
V2,バリデーションとビジネスロジック,V2.4,アンチオートメーション,V2.4.1,アンチオートメーションコントロールが導入され、データ流出、ガベージデータ作成、クォータ枯渇、レート制限違反、サービス拒否、高価なリソースの過剰使用につながる可能性のあるアプリケーション機能への過剰な呼び出しから保護している。,2
V2,バリデーションとビジネスロジック,V2.4,アンチオートメーション,V2.4.2,ビジネスロジックフローは現実的な人間のタイミングを必要とし、過度に迅速なトランザクション送信を防いでいる。,3
V3,Web フロントエンドセキュリティ,V3.1,Web フロントエンドセキュリティドキュメント,V3.1.1,アプリケーションドキュメントには、アプリケーションを使用するブラウザがサポートする必要がある想定されるセキュリティ機能 (HTTPS、HTTP Strict Transport Security (HSTS)、コンテンツセキュリティポリシー (CSP)、その他の関連する HTTP セキュリティメカニズムなど) を記載している。これらの機能の一部が利用できない場合にアプリケーションがどのように動作しなければならないか (ユーザへの警告やアクセスのブロックなど) も定義する必要がある。,3
V3,Web フロントエンドセキュリティ,V3.2,意図しないコンテンツ解釈,V3.2.1,ブラウザが不正なコンテキスト (API、ユーザがアップロードしたファイル、または他のリソースが直接リクエストされる場合など) で HTTP レスポンスのコンテンツや機能をレンダリングすることを防ぐために、セキュリティ制御が行われている。可能な制御には、HTTP リクエストヘッダフィールド (Sec-Fetch-\* など) が正しいコンテキストであることを示さない限りコンテンツを提供しないこと、Content-Security-Policy ヘッダフィールドの sandbox ディレクティブを使用するか、Content-Disposition ヘッダフィールドの attachment ディポジションタイプを使用することなどがある。,1
V3,Web フロントエンドセキュリティ,V3.2,意図しないコンテンツ解釈,V3.2.2,HTML としてレンダリングするのではなく、テキストとして表示することを意図したコンテンツは、HTML や JavaScript などのコンテンツの意図しない実行を防ぐために、安全なレンダリング関数 (createTextNode や textContent など) を使用して処理している。,1
V3,Web フロントエンドセキュリティ,V3.2,意図しないコンテンツ解釈,V3.2.3,アプリケーションは、明示的な変数宣言の採用、厳密な型チェックの実行、document オブジェクトへのグローバル変数の保存の回避、名前空間分離の実装によって、クライアントサイド JavaScript を使用する際の DOM clobbering を回避している。,3
V3,Web フロントエンドセキュリティ,V3.3,クッキーセットアップ,V3.3.1,クッキーには 'Secure' 属性が設定されており、クッキー名に '\__Host-' プレフィックスが使用されていない場合は、クッキー名に '__Secure-' プレフィックスを使用する必要がある。,1
V3,Web フロントエンドセキュリティ,V3.3,クッキーセットアップ,V3.3.2,各クッキーの 'SameSite' 属性値はクッキーの目的に応じて設定され、一般にクロスサイトリクエストフォージェリ (CSRF) として知られる、ユーザーインタフェースのリドレス攻撃やブラウザベースのリクエストフォージェリ攻撃への露出を制限している。,2
V3,Web フロントエンドセキュリティ,V3.3,クッキーセットアップ,V3.3.3,クッキーは、明示的に他のホストと共有するように設計されていない限り、クッキー名に '__Host-' プレフィックスを付けている。,2
V3,Web フロントエンドセキュリティ,V3.3,クッキーセットアップ,V3.3.4,クッキーの値がクライアントサイドスクリプトからアクセスされることを意図していない場合 (セッショントークンなど)、クッキーは 'HttpOnly' 属性が設定される必要があり、同じ値 (セッショントークンなど) は 'Set-Cookie' ヘッダフィールドを介してのみクライアントに転送される必要がある。,2
V3,Web フロントエンドセキュリティ,V3.3,クッキーセットアップ,V3.3.5,アプリケーションがクッキーを書き込む際、クッキー名と値を合わせた長さは 4096 バイトを超えない。大きすぎるクッキーはブラウザに保存されないため、リクエストとともに送信されず、ユーザはそのクッキーに依存するアプリケーション機能を使用できなくなる。,3
V3,Web フロントエンドセキュリティ,V3.4,ブラウザのセキュリティメカニズムヘッダ,V3.4.1,HTTP Strict Transport Security (HSTS) ポリシーを適用するために、Strict-Transport-Security ヘッダフィールドがすべてのレスポンスに含まれている。少なくとも 1 年間の最大有効期間を定義する必要があり、L2 以上では、ポリシーをすべてのサブドメインにも適用する必要がある。,1
V3,Web フロントエンドセキュリティ,V3.4,ブラウザのセキュリティメカニズムヘッダ,V3.4.2,クロスオリジンリソース共有 (CORS) Access-Control-Allow-Origin ヘッダフィールドがアプリケーションによって固定値にしている。または、Origin HTTP リクエストヘッダフィールド値が使用される場合は、信頼できるオリジンの厳密な許可リストに対して検証されている。'Access-Control-Allow-Origin: *' を使用する必要がある場合、レスポンスに機密情報が含まれていない。,1
V3,Web フロントエンドセキュリティ,V3.4,ブラウザのセキュリティメカニズムヘッダ,V3.4.3,HTTP レスポンスには Content-Security-Policy ヘッダフィールドを含み、悪意のある JavaScript の実行を制限するために、ブラウザが信頼できるコンテンツやリソースのみをロードして実行するようにディレクトリを定義している。少なくとも、ディレクティブ object-src 'none' および base-uri 'none' を含み、許可リストを定義するか、ナンスまたはハッシュを使用するグローバルポリシーを使用する必要がある。L3 アプリケーションでは、ナンスまたはハッシュを用いたレスポンスごとのポリシーを定義する必要がある。,2
V3,Web フロントエンドセキュリティ,V3.4,ブラウザのセキュリティメカニズムヘッダ,V3.4.4,すべての HTTP レスポンスには 'X-Content-Type-Options: nosniff' ヘッダフィールドを含んでいる。これは、与えられたレスポンスに対してコンテンツスニッフィングと MIME タイプ推測を使用しないようにブラウザに指示し、レスポンスの Content-Type ヘッダフィールド値が宛先リソースと一致することを要求します。たとえば、スタイルに対するリクエストへのレスポンスは、レスポンスの Content-Type が 'text/css' である場合にのみ受け入れられる。また、これによりブラウザの Cross-Origin Read Blocking (CORB) 機能の使用も可能にする。,2
V3,Web フロントエンドセキュリティ,V3.4,ブラウザのセキュリティメカニズムヘッダ,V3.4.5,アプリケーションは 'Referer' HTTP リクエストヘッダフィールドを介して、技術的に機密データがサードパーティサービスに漏洩することを防ぐために、リファラポリシーを設定している。これは Referrer-Policy HTTP レスポンスヘッダフィールドを使用するか、HTML 要素属性を介して使用して行うことができる。機密データは URL 内のパスやクエリデータ、そして内部の非公開アプリケーションではホスト名も含むことがある。,2
V3,Web フロントエンドセキュリティ,V3.4,ブラウザのセキュリティメカニズムヘッダ,V3.4.6,Web アプリケーションはすべての HTTP レスポンスに対して Content-Security-Policy ヘッダフィールドの frame-ancestors ディレクティブを使用して、デフォルトでは埋め込むことができないようにし、特定のリソースの埋め込みは必要な場合にのみ許可されるようにしている。X-Frame-Options ヘッダフィールドは、ブラウザによってサポートされているが、廃止されており、信頼できないことに注意する。,2
V3,Web フロントエンドセキュリティ,V3.4,ブラウザのセキュリティメカニズムヘッダ,V3.4.7,Content-Security-Policy ヘッダフィールドが違反を報告する場所を指定している。,3
V3,Web フロントエンドセキュリティ,V3.4,ブラウザのセキュリティメカニズムヘッダ,V3.4.8,ドキュメントのレンダリングを開始するすべての HTTP レスポンス (Content-Type text/html のレスポンスなど) には、必要に応じて、same-origin ディレクティブまたは the same-origin-allow-popups ディレクティブを持つ Cross‑Origin‑Opener‑Policy ヘッダフィールドを含んでいる。これにより、タブナビングやフレームカウンティングなど、Window オブジェクトへの共有アクセスを悪用する攻撃を防いでいる。,3
V3,Web フロントエンドセキュリティ,V3.5,ブラウザのオリジン分離,V3.5.1,アプリケーションが、機密機能を使用するための、許可されていないクロスオリジンリクエストを防ぐために、CORS プリフライトメカニズムに依存していない場合、これらのリクエストを検証して、アプリケーション自体から発信したものであることを確認している。これはフォージェリ防止トークンを使用して検証するか、CORS セーフリストリクエストヘッダフィールドではない追加の HTTP ヘッダフィールドを要求することで行われる。これは、一般にクロスサイトリクエストフォージェリ (CSRF) と呼ばれる、ブラウザベースのリクエストフォージェリ攻撃を防御するためのものである。,1
V3,Web フロントエンドセキュリティ,V3.5,ブラウザのオリジン分離,V3.5.2,アプリケーションが、機密機能の許可されていないクロスオリジン使用を防ぐために、CORS プリフライトメカニズムに依存している場合、CORS プリフライトリクエストをトリガーしないリクエストで機能を呼び出すことはできない。これは 'Origin' および 'Content-Type' リクエストヘッダフィールドの値をチェックするか、CORS セーフリストのヘッダフィールドではない追加のヘッダフィールドを使用する必要があるかもしれない。,1
V3,Web フロントエンドセキュリティ,V3.5,ブラウザのオリジン分離,V3.5.3,"機密機能の HTTP リクエストは POST, PUT, PATCH, DELETE などの適切な HTTP メソッドを使用し、HEAD, OPTIONS, GET などの HTTP 仕様で「安全」と定義されているメソッドを使用しない。あるいは、Sec-Fetch-* リクエストヘッダフィールドの厳密なバリデーションを使用して、不適切なクロスオリジンコール、ナビゲーションリクエスト、期待されていないリソースロード (画像ソースなど) からリクエストが発生していないことを確保している。",1
V3,Web フロントエンドセキュリティ,V3.5,ブラウザのオリジン分離,V3.5.4,あるオリジンでロードされたドキュメントやスクリプトが別のオリジンのリソースとやり取りする方法や、クッキーのホスト名制限など、同一オリジンポリシーによって提供される制限を活用するために、別のアプリケーションは異なるホスト名でホストされている。,2
V3,Web フロントエンドセキュリティ,V3.5,ブラウザのオリジン分離,V3.5.5,メッセージのオリジンが信頼できない場合、またはメッセージの構文が無効な場合、postMessage インタフェースによって受信したメッセージを破棄している。,2
V3,Web フロントエンドセキュリティ,V3.5,ブラウザのオリジン分離,V3.5.6,クロスサイトスクリプトインクルージョン (XSSI) 攻撃を避けるために、JSONP 機能はアプリケーションのどの部分でも有効になっていない。,3
V3,Web フロントエンドセキュリティ,V3.5,ブラウザのオリジン分離,V3.5.7,クロスサイトスクリプトインクルージョン (XSSI) 攻撃を防ぐために、認可が必要なデータは JavaScript ファイルなどのスクリプトリソースレスポンスには含まれていない。,3
V3,Web フロントエンドセキュリティ,V3.5,ブラウザのオリジン分離,V3.5.8,認証されたリソース (画像、動画、スクリプト、その他のドキュメントなど) は、意図した場合にのみユーザの代わりにロードまたは埋め込むことができる。これは、Sec-Fetch-* HTTP リクエストヘッダフィールドの厳密なバリデーションにより、リクエストが不適切なクロスオリジンコールから生じたものではないことを確保するか、制限的な Cross-Origin-Resource-Policy HTTP レスポンスヘッダフィールドを設定することにより、ブラウザが返されたコンテンツをブロックするように指示することで実現できる。,3
V3,Web フロントエンドセキュリティ,V3.6,外部リソース完全性,V3.6.1,"JavaScript ライブラリ、CSS、Web フォントなどのクライアントサイド資産は、リソースが静的かつバージョン管理されており、サブリソース完全性 (Subresource Integrity, SRI) を使用して資産の完全性を検証している場合にのみ、外部 (コンテンツ配信ネットワーク (Content Delivery Network) など) にホストされている。これが不可能な場合は、各リソースについて、この正当性を証明するセキュリティ上の決定事項を文書化する必要がある。",3
V3,Web フロントエンドセキュリティ,V3.7,ブラウザのセキュリティに関するその他の考慮事項,V3.7.1,アプリケーションは依然としてサポートされており安全であると考えられているクライアントサイドのテクノロジのみを使用している。この要件を満たさないテクノロジの例としては NSAPI プラグイン、Flash、Shockwave、ActiveX、Silverlight、NACL、クライアントサイド Java アプレットなどがある。,2
V3,Web フロントエンドセキュリティ,V3.7,ブラウザのセキュリティに関するその他の考慮事項,V3.7.2,アプリケーションは、宛先が許可リストに記載されている別のホスト名やドメイン (アプリケーションで制御されていない) にのみユーザーを自動的にリダイレクトしている。,2
V3,Web フロントエンドセキュリティ,V3.7,ブラウザのセキュリティに関するその他の考慮事項,V3.7.3,ユーザがアプリケーションの制御外の URL にリダイレクトされる場合、アプリケーションはナビゲーションをキャンセルするオプションとともに通知を表示している。,3
V3,Web フロントエンドセキュリティ,V3.7,ブラウザのセキュリティに関するその他の考慮事項,V3.7.4,アプリケーションのトップレベルドメイン (例: site.tld) が HTTP Strict Transport Security (HSTS) のパブリックプリロードリストに追加されている。これにより、アプリケーションの TLS の使用が、Strict-Transport-Security レスポンスヘッダフィールドのみに依存するのではなく、メインブラウザに直接組み込まれるようになる。,3
V3,Web フロントエンドセキュリティ,V3.7,ブラウザのセキュリティに関するその他の考慮事項,V3.7.5,アプリケーションへのアクセスに使用されるブラウザが、想定されるセキュリティ機能をサポートしていない場合、アプリケーションはドキュメントに記載されているとおりに動作する (ユーザへの警告やアクセスのブロックなど)。,3
V4,API と Web サービス,V4.1,一般的な Web サービスセキュリティ,V4.1.1,"メッセージボディを持つすべての HTTP レスポンスにはレスポンスの実際のコンテンツと一致する Content-Type ヘッダフィールドを含んでいる。これには ""text/"", ""/+xml"", ""/xml"" などの IANA メディアタイプに従って安全な文字エンコーディング (UTF-8, ISO-8859-1 など) を指定する charset パラメータを含んでいる。",1
V4,API と Web サービス,V4.1,一般的な Web サービスセキュリティ,V4.1.2,ユーザ向けのエンドポイント (手動でのウェブブラウザアクセス用) のみが HTTP から HTTPS に自動的にリダイレクトし、他のサービスやエンドポイントでは透過的なリダイレクトを実装していない。これは、クライアントが誤って暗号化されていない HTTP リクエストを送信しても、リクエストが自動的に HTTPS に自動的にリダイレクトされるため機密データの漏洩が発見されない、という状況を避けるためである。,2
V4,API と Web サービス,V4.1,一般的な Web サービスセキュリティ,V4.1.3,"アプリケーションにより使用され、ロードバランサ、Web プロキシ、backend-for-frontend サービスなどの中間層により設定される HTTP ヘッダフィールドはエンドユーザによって上書きできない。ヘッダの例としては X-Real-IP, X-Forwarded-*, X-User-ID などがある。",2
V4,API と Web サービス,V4.1,一般的な Web サービスセキュリティ,V4.1.4,アプリケーションまたはその API によって明示的にサポートされている HTTP メソッド (preflight リクエスト時の OPTIONS を含む) のみが使用でき、未使用のメソッドはブロックされる。,3
V4,API と Web サービス,V4.1,一般的な Web サービスセキュリティ,V4.1.5,メッセージごとのデジタル署名を使用して、機密性が高いリクエストやトランザクションや、多数のシステムを横断するリクエストまたはトランザクションに対して、トランスポート保護の上にさらなる保証を提供している。,3
V4,API と Web サービス,V4.2,HTTP メッセージ構造バリデーション,V4.2.1,すべてのアプリケーションコンポーネント (ロードバランサ、ファイアウォール、アプリケーションサーバを含む) は、HTTP バージョンに適したメカニズムを使用して、受信 HTTP メッセージの境界を決定し、HTTP リクエストスマグリングを防いでいる。HTTP/1.x では、Transfer-Encoding ヘッダフィールドが存在する場合、Content-Length ヘッダフィールドを RFC 2616 に従って無視する必要がある。HTTP/2 または HTTP/3 を使用する際に、Content-Length ヘッダフィールドが存在する場合、受信側はそれが DATA フレームの長さと一致することを確保する必要がある。,2
V4,API と Web サービス,V4.2,HTTP メッセージ構造バリデーション,V4.2.2,HTTP メッセージを生成する際、HTTP リクエストスマグリングを防ぐために、Content-Length ヘッダフィールドが HTTP プロトコルのフレームで決定されるコンテンツの長さと競合しない。,3
V4,API と Web サービス,V4.2,HTTP メッセージ構造バリデーション,V4.2.3,アプリケーションは、レスポンス分割やヘッダインジェクション攻撃を防ぐために、Transfer-Encoding などの接続固有のヘッダフィールドを持つ HTTP/2 や HTTP/3 メッセージを送受信しない。,3
V4,API と Web サービス,V4.2,HTTP メッセージ構造バリデーション,V4.2.4,アプリケーションは、ヘッダインジェクション攻撃を防ぐために、ヘッダフィールドと値に CR (\r)、LF (\n)、CRLF (\r\n) シーケンスを含まない HTTP/2 および HTTP/3 リクエストのみを受け付ける。,3
V4,API と Web サービス,V4.2,HTTP メッセージ構造バリデーション,V4.2.5,アプリケーション (バックエンドまたはフロントエンド) がリクエストを構築して送信する場合、バリデーション、サニタイゼーション、またはその他のメカニズムを使用して、受信コンポーネントで受け入れられるには長すぎる URI (API 呼び出しのためなど) や HTTP リクエストヘッダフィールド (認可やクッキーのためなど) の作成を回避している。長すぎるリクエスト (長いクッキーヘッダフィールドなど) を送信すると、サーバが常にエラーステータスで応答するなど、サービス拒否を引き起こす可能性がある。,3
V4,API と Web サービス,V4.3,GraphQL,V4.3.1,コストが高く、ネストされたクエリの結果としての GraphQL やデータレイヤエクスプレッションのサービス拒否 (DoS) を防止するために、クエリ許可リスト、深さ制限、量制限、またはクエリコスト分析を使用している。,2
V4,API と Web サービス,V4.3,GraphQL,V4.3.2,Graph API が他の関係者により使用されることを意図している場合を除き、本番環境では GraphQL イントロスペクションクエリが無効になっている。,2
V4,API と Web サービス,V4.4,WebSocket,V4.4.1,WebSocket over TLS (WSS) がすべての WebSocket 接続に使用されている。,1
V4,API と Web サービス,V4.4,WebSocket,V4.4.2,最初の HTTP WebSocket ハンドシェイクで Origin ヘッダフィールドがアプリケーションで許可されているオリジンのリストと照合されている。,2
V4,API と Web サービス,V4.4,WebSocket,V4.4.3,アプリケーションの標準セッション管理を使用できない場合、関連するセッション管理セキュリティ要件に準拠した専用トークンが使用されている。,2
V4,API と Web サービス,V4.4,WebSocket,V4.4.4,専用の WebSocket セッション管理トークンは、既存の HTTPS セッションを WebSocket チャネルに移行するときに、以前に認証された HTTPS セッションを通じて最初に取得または検証されます。,2
V5,ファイル処理,V5.1,ファイル処理ドキュメント,V5.1.1,ドキュメントでは各アップロード機能で許可されるファイルタイプ、想定されるファイル拡張子、最大サイズ (展開後のサイズを含む) を定義している。さらに、悪意のあるファイルが検出された場合にアプリケーションがどのように動作するかなど、ドキュメントにはエンドユーザがファイルをダウンロードして処理する際に安全を確保する方法を指定している。,2
V5,ファイル処理,V5.2,ファイルアップロードとコンテンツ,V5.2.1,アプリケーションはパフォーマンスの低下やサービス拒否攻撃を引き起こすことなく処理可能なサイズのファイルのみを受け付けている。,1
V5,ファイル処理,V5.2,ファイルアップロードとコンテンツ,V5.2.2,アプリケーションはファイルを受け入れる際に、それ自体または zip ファイルなどのアーカイブ内のいずれかで、ファイル拡張子が予期されるファイル拡張子と一致するかどうかをチェックし、内容がその拡張子で表されるタイプに対応しているかどうかを検証している。これには最初の 'マジックバイト' のチェック、イメージの再書き込みの実行、ファイル内容のバリデーションのための専用ライブラリの使用が含まれるがこれに限定されない。L1 では、特定のビジネスまたはセキュリティ上の決定を行うために使用されるファイルのみに焦点を当てることができる。L2 以上では、受け入れられるすべてのファイルに適用する必要がある。,1
V5,ファイル処理,V5.2,ファイルアップロードとコンテンツ,V5.2.3,"アプリケーションが圧縮ファイル (zip, gz, docx, odt など) を展開する前に最大許容非圧縮サイズおよび最大ファイル数と照合している。",2
V5,ファイル処理,V5.2,ファイルアップロードとコンテンツ,V5.2.4,一人のユーザがあまりにも多くのファイルや極端に大きいファイルでストレージを圧迫させることができないように、ユーザあたりのファイルサイズクォータと最大ファイル数が適用されている。,3
V5,ファイル処理,V5.2,ファイルアップロードとコンテンツ,V5.2.5,特に必要な場合 (その場合、シンボリックリンクできるファイルの許可リストを適用する必要がある) を除き、アプリケーションはシンボリックリンクを含む圧縮ファイルのアップロードを許可していない。,3
V5,ファイル処理,V5.2,ファイルアップロードとコンテンツ,V5.2.6,アプリケーションはピクセルフラッド攻撃を防ぐために、許容される最大値を超えるピクセルサイズのアップロードされた画像を拒否している。,3
V5,ファイル処理,V5.3,ファイル保存,V5.3.1,信頼できない入力によってアップロードまたは生成され、パブリックフォルダに保存されたファイルは、HTTP リクエストで直接アクセスした場合、サーバサイドのプログラムコードとして実行できない。,1
V5,ファイル処理,V5.3,ファイル保存,V5.3.2,"アプリケーションがファイル操作のためにファイルパスを作成する際、ユーザが送信したファイル名の代わりに、内部で生成されたデータまたは信頼できるデータを使用する。また、ユーザが送信したファイル名やファイルメタデータを使用する必要がある場合は、厳密なバリデーションとサニタイゼーションを適用する必要がある。これは、パストラバーサル、ローカルまたはリモートファイルインクルージョン (LFI, RFI)、サーバサイドリクエストフォージェリ (SSRF) 攻撃から保護するためである。",1
V5,ファイル処理,V5.3,ファイル保存,V5.3.3,zip スリップなどの脆弱性を防ぐために、ファイル展開などのサーバサイドのファイル処理が、ユーザから提供されたパス情報を無視する。,3
V5,ファイル処理,V5.4,ファイルダウンロード,V5.4.1,アプリケーションが JSON、JSONP、URL パラメータに含まれるユーザが送信したファイル名を確認または無視し、レスポンスの Content-Disposition ヘッダフィールドでファイル名を指定している。,2
V5,ファイル処理,V5.4,ファイルダウンロード,V5.4.2,提供されるファイル名 (HTTP レスポンスヘッダフィールドや電子メールの添付ファイルなど) は、ドキュメント構造を保持し、インジェクション攻撃を防ぐために、エンコードまたはサニタイズされている (RFC 6266 に従うなど)。,2
V5,ファイル処理,V5.4,ファイルダウンロード,V5.4.3,信頼できない場所から取得したファイルが、既知の悪意のあるコンテンツの配信を防ぐためにアンチウィルススキャナで検査されている。,2
V6,認証,V6.1,認証ドキュメント,V6.1.1,アプリケーションドキュメントでは、レート制限、自動化防止、適用応答などのコントロールが、クレデンシャルスタッフィングやパスワードブルートフォースなどの攻撃から防御するためにどのように使用されるかを定義している。このドキュメントでは、これらのコントロールがどのように構成されるかを明確にし、悪意のあるアカウントロックアウトを防ぐ必要がある。,1
V6,認証,V6.1,認証ドキュメント,V6.1.2,コンテキスト固有の単語のリストが文書化されており、パスワードでの使用を防いでいる。このリストには、組織名、製品名、システム識別子、プロジェクトコード名、部門名、ロール名などの配列を含むことがある。,2
V6,認証,V6.1,認証ドキュメント,V6.1.3,アプリケーションに複数の認証経路がある場合、それらすべてに一貫して適用される必要があるセキュリティ制御と認証強度がともに文書化されている。,2
V6,認証,V6.2,パスワードセキュリティ,V6.2.1,ユーザが設定するパスワードの長さは少なくとも 8 文字であるが、最低限 15 文字にすることを強く推奨している。,1
V6,認証,V6.2,パスワードセキュリティ,V6.2.2,ユーザは自身のパスワードを変更できる。,1
V6,認証,V6.2,パスワードセキュリティ,V6.2.3,パスワード変更機能にはユーザの現在のパスワードと新しいパスワードが必要とされる。,1
V6,認証,V6.2,パスワードセキュリティ,V6.2.4,アカウント登録またはパスワード変更時に送信されるパスワードは、アプリケーションのパスワードポリシー (最小長など) に合致する、少なくとも上位 3000 件の利用可能な一連のパスワードと照合されている。,1
V6,認証,V6.2,パスワードセキュリティ,V6.2.5,パスワードはどのような構成でも使用でき、許可される文字の種類を制限するルールはない。大文字、小文字、数字、特殊文字の最低数についての要求を設けてはいけない。,1
V6,認証,V6.2,パスワードセキュリティ,V6.2.6,パスワード入力フィールドは type=password を使用して、そのエントリをマスクしている。アプリケーションはユーザがマスクしたパスワード全体または最後に入力したパスワードの文字を一時的に閲覧できるようにしている。,1
V6,認証,V6.2,パスワードセキュリティ,V6.2.7,「貼り付け」機能、ブラウザのパスワードヘルパー、および外部のパスワードマネージャが許可されている。,1
V6,認証,V6.2,パスワードセキュリティ,V6.2.8,アプリケーションは切り捨てや大文字小文字の変換などの修正をなにも加えずに、ユーザーから受け取ったパスワードを正確に検証している。,1
V6,認証,V6.2,パスワードセキュリティ,V6.2.9,64 文字以上のパスワードが許可されている。,2
V6,認証,V6.2,パスワードセキュリティ,V6.2.10,ユーザのパスワードは侵害されたことが判明するか、ユーザーが変更するまで有効のままである。アプリケーションは定期的なクレデンシャルの変更を要求してはいけない。,2
V6,認証,V6.2,パスワードセキュリティ,V6.2.11,コンテキスト固有の単語の文書化されたリストを使用して、推測されやすいパスワードが作成されることを防いでいる。,2
V6,認証,V6.2,パスワードセキュリティ,V6.2.12,アカウント登録またはパスワード変更時に送信されるパスワードは一連の侵害されたパスワードと照合されている。,2
V6,認証,V6.3,一般的な認証セキュリティ,V6.3.1,クレデンシャルスタッフィングやパスワードブルートフォースなどの攻撃を防ぐためのコントロールは、アプリケーションのセキュリティドキュメントに従って実装されている。,1
V6,認証,V6.3,一般的な認証セキュリティ,V6.3.2,"デフォルトユーザーアカウント (""root"", ""admin"", ""sa"" など) がアプリケーションに存在しないか、無効になっている。",1
V6,認証,V6.3,一般的な認証セキュリティ,V6.3.3,アプリケーションにアクセスするには、多要素認証メカニズム、または単要素認証のメカニズムの組み合わせのいずれかを使用する必要がある。L3 では、ユーザによるアクション (FIDO ハードウェアキーやスマートフォンのボタン押下など) を要求することで認証の意図を検証しつつ、フィッシング攻撃に対する侵害やなりすましへの耐性を提供しているハードウェアベースの認証メカニズムが要素の一つである必要がある。この要件における考慮事項のいずれかを緩和するには、十分に文書化された根拠と包括的な緩和策を必要とする。,2
V6,認証,V6.3,一般的な認証セキュリティ,V6.3.4,アプリケーションに複数の認証経路がある場合、文書化されていない経路がなく、セキュリティ制御と認証強度が一貫して適用されている。,2
V6,認証,V6.3,一般的な認証セキュリティ,V6.3.5,不審な認証試行 (成功または失敗) があった場合にユーザに通知されている。これには、通常とは異なる場所やクライアントからの認証試行、部分的に成功した認証 (多要素のうち一つのみ)、長期間使用されなかった後の認証試行、複数回失敗した後に成功した認証などがある。,3
V6,認証,V6.3,一般的な認証セキュリティ,V6.3.6,電子メールは単要素認証メカニズムとしても多要素認証メカニズムとしても使用されない。,3
V6,認証,V6.3,一般的な認証セキュリティ,V6.3.7,クレデンシャルのリセットや、ユーザ名や電子メールアドレスの変更など、認証情報の更新された後に、ユーザに通知されている。,3
V6,認証,V6.3,一般的な認証セキュリティ,V6.3.8,エラーメッセージ、HTTP レスポンスコード、またはさまざまなレスポンスタイムなどに基づくことによって、失敗した認証チャレンジから有効なユーザーを推定することはできない。登録とパスワード忘れ機能にもこの保護が必要である。,3
V6,認証,V6.4,認証要素のライフサイクルとリカバリ,V6.4.1,システムで生成される初期パスワードやアクティベーションコードは安全にランダムに生成され、既存のパスワードポリシーに従い、短期間または初期使用後に失効している。これらの初期シークレットが長期パスワードになることは許可されない。,1
V6,認証,V6.4,認証要素のライフサイクルとリカバリ,V6.4.2,パスワードのヒントや知識ベースの認証 (いわゆる「秘密の質問」) が存在しない。,1
V6,認証,V6.4,認証要素のライフサイクルとリカバリ,V6.4.3,忘れたパスワードをリセットするための安全なプロセスが実装されており、有効になっている多要素認証メカニズムをバイパスしない。,2
V6,認証,V6.4,認証要素のライフサイクルとリカバリ,V6.4.4,多要素認証要素が失われた場合、登録時と同じレベルで同一性証明の証拠が実行される。,2
V6,認証,V6.4,認証要素のライフサイクルとリカバリ,V6.4.5,期限切れになる認証メカニズムの更新指示は、古い認証メカニズムの期限が切れる前に実行できるように、十分な時間をとって送信され、必要に応じて自動リマインダを設定している。,3
V6,認証,V6.4,認証要素のライフサイクルとリカバリ,V6.4.6,管理ユーザはユーザのパスワードリセット処理を開始できるが、ユーザのパスワードを変更したり選択することはできない。これによりユーザのパスワードを管理ユーザに知られる状況を防いでいる。,3
V6,認証,V6.5,一般的な多要素認証要件,V6.5.1,ルックアップシークレット、経路外認証リクエストまたはコード、時間ベースのワンタイムパスワード (TOTP) は一度のみ正常に使用できる。,2
V6,認証,V6.5,一般的な多要素認証要件,V6.5.2,アプリケーションのバックエンドに保存される際、112 ビット未満のエントロピー (19 個のランダムな英数字または 34 個のランダムな数字) を持つルックアップシークレットは、32 ビットのランダムソルトを組み込んだ承認済みのパスワードストレージハッシュアルゴリズムでハッシュされる。シークレットが 112 ビット以上のエントロピーを持つ場合は、標準的なハッシュ関数を使用できる。,2
V6,認証,V6.5,一般的な多要素認証要件,V6.5.3,"ルックアップシークレット、経路外認証コード、時間ベースのワンタイムパスワードのシードは、予測可能な値を避けるために暗号論的に安全な疑似乱数生成器 (Cryptographically Secure Pseudorandom Number Generator, CSPRNG) を使用して生成されている。",2
V6,認証,V6.5,一般的な多要素認証要件,V6.5.4,ルックアップシークレットと経路外認証コードは最低 20 ビットのエントロピー (通常 4 個のランダムな英数字または 6 個のランダムな数字で十分です) を持っている。,2
V6,認証,V6.5,一般的な多要素認証要件,V6.5.5,経路外認証リクエスト、コード、トークン、および時間ベースのワンタイムパスワード (TOTP) は定められた有効期間を持っている。経路外リクエストでは最大有効時間を 10 分にする必要があり、TOTP では最大有効時間を 30 秒とする必要がある。,2
V6,認証,V6.5,一般的な多要素認証要件,V6.5.6,あらゆる認証要素 (物理デバイスを含む) は盗難やその他の紛失の場合に無効化できる。,3
V6,認証,V6.5,一般的な多要素認証要件,V6.5.7,生体認証メカニズムは所有物認証 (something you have) または知識認証 (something you know) のいずれかと一緒に、二次的要素としてのみ使用されている。,3
V6,認証,V6.5,一般的な多要素認証要件,V6.5.8,時間ベースのワンタイムパスワード (TOTP) は、信頼できない時間やクライアントが提供する時間ではなく、信頼できるサービスからの時間ソースに基づいてチェックされている。,3
V6,認証,V6.6,経路外認証メカニズム,V6.6.1,公衆交換電話網 (PSTN) を使用して電話または SMS 経由でワンタイムパスワード (OTP) を配信する認証メカニズムは、電話番号が事前に検証され、より強力な代替手段 (時間ベースのワンタイムパスワードなど) も提供され、サービスがそのセキュリティリスクに関する情報をユーザに提供する場合にのみ提供される。L3 アプリケーションでは、電話と SMS はオプションとして利用してはいけない。,2
V6,認証,V6.6,経路外認証メカニズム,V6.6.2,経路外認証リクエスト、コード、またはトークンはそれらが生成された元の認証リクエストにバインドされており、それ以前やそれ以降のものに対しては使用できない。,2
V6,認証,V6.6,経路外認証メカニズム,V6.6.3,コードベースの経路外認証メカニズムはレート制限を使用して、ブルートフォース攻撃から保護されている。また、少なくとも64ビットのエントロピーを持つコードの使用も検討する。,2
V6,認証,V6.6,経路外認証メカニズム,V6.6.4,プッシュ通知が多要素認証に使用される場合、レート制限を使用して、プッシュ爆撃攻撃を防いでいる。また、番号照合もこのリスクを緩和できることがある。,3
V6,認証,V6.7,暗号認証メカニズム,V6.7.1,暗号認証アサーションを検証するために使用される証明書は、変更から保護される方法で保存されている。,3
V6,認証,V6.7,暗号認証メカニズム,V6.7.2,チャレンジナンスは少なくとも 64 ビットの長さがあり、統計的に一意か、暗号デバイスの有効期間を通じて一意となっている。,3
V6,認証,V6.8,アイデンティティプロバイダによる認証,V6.8.1,アプリケーションが複数のアイデンティティプロバイダ (IdP) をサポートしている場合、サポートされている別のアイデンティティプロバイダを介して (たとえば同じユーザ識別子を使用して) ユーザのアイデンティティを偽装できない。標準的な緩和策としてはアプリケーションが (名前空間として機能する) IdP ID と IdP 内のユーザ ID の組み合わせを使用して、ユーザを登録および識別することである。,2
V6,認証,V6.8,アイデンティティプロバイダによる認証,V6.8.2,認証アサーション (JWT や SAML アサーションなど) のデジタル署名の存在と完全性は常に検証され、署名されていないアサーションや無効な署名を持つアサーションは拒否される。,2
V6,認証,V6.8,アイデンティティプロバイダによる認証,V6.8.3,SAML アサーションは一意に処理され、有効期間内に一度だけ使用され、リプレイ攻撃を防いでいる。,2
V6,認証,V6.8,アイデンティティプロバイダによる認証,V6.8.4,"アプリケーションが別のアイデンティティプロバイダ (IdP) を使用し、特定の機能に対して特定の認証強度、認証方法、認証日時を期待する場合、アプリケーションは IdP から返される情報を使用してこれを検証している。たとえば、OIDC を使用する場合、これは 'acr', 'amr', 'auth_time' (存在する場合) などの ID トークンクレームを検証することで実現できる。IdP がこの情報を提供しない場合、アプリケーションは最低限の強度の認証メカニズム (たとえば、ユーザ名とパスワードを使用した単要素認証) が使用されたと想定する、文書化されたフォールバックアプローチを備えている必要がある。",2
V7,セッション管理,V7.1,セッション管理ドキュメント,V7.1.1,ユーザのセッション非アクティブタイムアウトと絶対最大セッション有効期間が文書化され、他のコントロールと組み合わせて適切であり、そのドキュメントには NIST SP 800-63B 再認証要件からの逸脱の正当性が含まれている。,2
V7,セッション管理,V7.1,セッション管理ドキュメント,V7.1.2,ドキュメントには、一つのアカウントで許可される同時 (並列) セッションの数と、アクティブセッションの最大数に達した場合に実行される意図した動作やアクションを定義している。,2
V7,セッション管理,V7.1,セッション管理ドキュメント,V7.1.3,フェデレーション ID (federated identity) 管理エコシステムの一部としてユーザセッションを作成および管理するすべてのシステム (SSO システムなど) は、セッションの有効期間、終了、および再認証を必要とするその他の状態を調整するためのコントロールとともに文書化している。,2
V7,セッション管理,V7.2,基本セッション管理セキュリティ,V7.2.1,アプリケーションが信頼できるバックエンドサービスを使用してすべてのセッショントークン検証を実行している。,1
V7,セッション管理,V7.2,基本セッション管理セキュリティ,V7.2.2,アプリケーションがセッション管理に動的に生成される自己完結型トークンまたはリファレンストークンを使用している。つまり、静的な API シークレットと API キーは使用していない。,1
V7,セッション管理,V7.2,基本セッション管理セキュリティ,V7.2.3,リファレンストークンがユーザセッションを表すために使用される場合、そのトークンは一意であり、暗号論的に安全な疑似乱数生成器 (CSPRNG) を使用して生成され、少なくとも 128 ビットのエントロピーを持つ。,1
V7,セッション管理,V7.2,基本セッション管理セキュリティ,V7.2.4,アプリケーションがユーザ認証 (再認証を含む) 時に新しいセッショントークンを生成し、現在のセッショントークンを終了する。,1
V7,セッション管理,V7.3,セッションタイムアウト,V7.3.1,文書化されたセキュリティ上の決定に従って再認証が強制されるような、非アクティブタイムアウトがある。,2
V7,セッション管理,V7.3,セッションタイムアウト,V7.3.2,リスク分析と文書化されたセキュリティ上の決定に従って再認証が強制されるような、絶対的な最大セッション存続期間がある。,2
V7,セッション管理,V7.4,セッションの終了,V7.4.1,セッションの終了 (ログアウトや期限切れなど) がトリガーされると、アプリケーションはセッションのそれ以上の使用を禁止している。リファレンストークンやステートフルセッションでは、これはアプリケーションバックエンドでセッションデータを無効にすることを意味する。自己完結型トークンを使用するアプリケーションでは、終了したトークンのリストを保持する、ユーザごとに所定の日時より前に生成されたトークンを禁止する、ユーザごとに署名鍵を入れ替えるなどの解決策が必要になる。,1
V7,セッション管理,V7.4,セッションの終了,V7.4.2,ユーザアカウントが無効または削除された場合 (従業員の退職など) 、アプリケーションはすべてのアクティブなセッションを終了する。,1
V7,セッション管理,V7.4,セッションの終了,V7.4.3,認証要素が正常に変更または削除 (リセットやリカバリーによるパスワード変更や、存在する場合、MFA 設定の更新を含む) された後、アプリケーションが他のすべてのアクティブセッションを終了するためのオプションを提供している。,2
V7,セッション管理,V7.4,セッションの終了,V7.4.4,認証を必要とするすべてのページでログアウト機能に簡単かつ目に見える形でアクセスできる。,2
V7,セッション管理,V7.4,セッションの終了,V7.4.5,アプリケーション管理者は個々のユーザーまたはすべてのユーザーのアクティブなセッションを終了できる。,2
V7,セッション管理,V7.5,セッションの悪用に対する防御,V7.5.1,アプリケーションは、電子メールアドレス、電話番号、MFA 構成、アカウントリカバリに使用されるその他の情報など、認証に影響する可能性のある機密性の高いアカウント属性の変更を許可する前に、完全な再認証を要求している。,2
V7,セッション管理,V7.5,セッションの悪用に対する防御,V7.5.2,ユーザは、現在のアクティブセッションの一部またはすべてを表示し、(少なくとも一つの要素で再度認証することで) 終了することができる。,2
V7,セッション管理,V7.5,セッションの悪用に対する防御,V7.5.3,アプリケーションは、機密性の高いトランザクションや操作を実行する前に、少なくとも一つの要素での追加の認証または二次検証を要求している。,3
V7,セッション管理,V7.6,フェデレーション再認証,V7.6.1,"依拠当事者 (Relying Party, RP) とアイデンティティプロバイダ (Identity Provider, IdP) 間のセッションの有効期間と終了は文書化されたとおりに動作し、IdP 認証イベント間の最大時間に達した場合など、必要に応じて再認証を要求している。",2
V7,セッション管理,V7.6,フェデレーション再認証,V7.6.2,セッションの作成にはユーザの同意または明示的なアクションが必要であり、ユーザとのやり取りなしに新しいアプリケーションセッションが作成されることを防いでいる。,2
V8,認可,V8.1,認可ドキュメント,V8.1.1,認可ドキュメントは、コンシューマのパーミッションとリソース属性に基づいて、機能レベルとデータ固有のアクセスを制限するためのルールを定義している。,1
V8,認可,V8.1,認可ドキュメント,V8.1.2,認可ドキュメントは、コンシューマのパーミッションとリソース属性に基づいて、フィールドレベルのアクセス (読み取りと書き込みの両方) を制限するためのルールを定義している。これらのルールは、状態やステータスなど、関連するデータオブジェクトの他の属性値に依存する可能性があることに注意する。,2
V8,認可,V8.1,認可ドキュメント,V8.1.3,アプリケーションのドキュメントは、認証と認可に関連するものを含め、セキュリティ上の決定をするために、アプリケーションで使用される環境属性とコンテキスト属性 (時間帯、ユーザの位置情報、IP アドレス、デバイスなどを含むがこれらに限定されない) を定義している。,3
V8,認可,V8.1,認可ドキュメント,V8.1.4,認証と認可のドキュメントは、機能レベル、データ固有、フィールドレベルの認可に加えて、環境要因とコンテキスト要因が意思決定でどのように使用されるかを定義している。これは、評価される属性、リスクの閾値、実行されるアクション (許可、チャレンジ、拒否、ステップアップ認証など) を含む必要がある。,3
V8,認可,V8.2,一般的な認可設計,V8.2.1,アプリケーションは機能レベルのアクセスが明示的なパーミッションを持つコンシューマに制限されることを確保している。,1
V8,認可,V8.2,一般的な認可設計,V8.2.2,アプリケーションは、安全でない直接オブジェクト参照 (IDOR) と壊れたオブジェクトレベル認可 (BOLA) を軽減するために、データ固有のアクセスが特定のデータ項目に対する明示的なパーミッションを持つコンシューマに制限されることを確保している。,1
V8,認可,V8.2,一般的な認可設計,V8.2.3,アプリケーションは、壊れたオブジェクトプロパティレベル認可 (BOPLA) を軽減するために、フィールドレベルのアクセスが特定のフィールドに対する明示的なパーミッションを持つコンシューマに制限されることを確保している。,2
V8,認可,V8.2,一般的な認可設計,V8.2.4,アプリケーションのドキュメントに定義されているように、認証と認可の決定には、コンシューマの環境属性とコンテキスト属性 (時間帯、位置情報、IP アドレス、デバイスなど) に基づく適応型セキュリティコントロールが実装されている。これらのコントロールは、コンシューマが新しいセッションを開始しようとするときだけでなく、既存のセッション中にも適用する必要がある。,3
V8,認可,V8.3,操作レベルの認可,V8.3.1,アプリケーションは信頼できるサービス層で認可ルールを適用し、クライアントサイド JavaScript など、信頼できないコンシューマが操作できるコントロールに依存していない。,1
V8,認可,V8.3,操作レベルの認可,V8.3.2,認可の決定が行われた値の変更は即座に適用されている。変更を即座に適用できない場合 (自己完結型トークンのデータに依存している場合など)、コンシューマがもはや認可されていないアクションを実行したときに警告を発し、その変更を元に戻すための緩和コントロールが必要である。この代替手段では情報漏洩を緩和しないことに注意する。,3
V8,認可,V8.3,操作レベルの認可,V8.3.3,オブジェクトへのアクセスは、発信主体 (コンシューマなど) のパーミッションに基づいており、代理で動作する仲介者やサービスのパーミッションではない。たとえば、コンシューマが認証のために自己完結型トークンを使用して Web サービスを呼び出し、それからそのサービスが別のサービスにデータをリクエストする場合、二番目のサービスは、最初のサービスからのマシン間トークンではなく、コンシューマのトークンを使用してパーミッションを決定する。,3
V8,認可,V8.4,他の認可の考慮,V8.4.1,マルチテナントアプリケーションはクロステナントコントロールを使用して、コンシューマ操作が、インタラクションするパーミッションを持たないテナントに決して影響を与えないようにしている。,2
V8,認可,V8.4,他の認可の考慮,V8.4.2,管理インタフェースへのアクセスは、継続的なコンシューマアイデンティティ検証、デバイスセキュリティ態勢評価、コンテキストリスク分析など、複数レイヤのセキュリティを組み込んでおり、ネットワークの場所や信頼できるエンドポイントが、認可されていないアクセスの可能性を減らすことはあるものの、認可の唯一の要素にはならないようにしている。,3
V9,自己完結型トークン,V9.1,トークンのソースと完全性,V9.1.1,自己完結型トークンがデジタル署名または MAC を使用して検証され、トークンのコンテンツを受け入れる前に改竄を防いでいる。,1
V9,自己完結型トークン,V9.1,トークンのソースと完全性,V9.1.2,特定のコンテキストでは、許可リストにあるアルゴリズムのみを使用して、自己完結型トークンを作成および検証している。許可リストには、許可されたアルゴリズム、理想的には対称アルゴリズムあるいは非対称アルゴリズムのいずれかのみ、を含める必要があり、'None' アルゴリズムを含めてはいけない。対称と非対称の両方がサポートされる必要がある場合は、追加のコントロールで鍵の混乱を防ぐ必要がある。,1
V9,自己完結型トークン,V9.1,トークンのソースと完全性,V9.1.3,"自己完結型トークンを検証するために使用される鍵マテリアルは、トークン発行者の事前設定済みの信頼できるソースからのものであり、攻撃者が信頼できないソースや鍵を指定することを防いでいる。JWT やその他の JWS 構造では、'jku', 'x5u', 'jwk' などのヘッダは信頼できるソースの許可リストに照らして検証しなけれならない。",1
V9,自己完結型トークン,V9.2,トークンコンテンツ,V9.2.1,トークンデータに有効期間がある場合、トークンとそのコンテンツは検証時間がこの有効期間内である場合にのみ受け入れられる。たとえば、JWT では、クレーム 'nbf' と 'exp' を検証する必要がある。,1
V9,自己完結型トークン,V9.2,トークンコンテンツ,V9.2.2,トークンを受け取るサービスは、トークンの内容を受け入れる前に、トークンが正しいタイプであり、意図した目的に適していることを検証している。たとえば、認可の決定にはアクセストークンのみを受け入れることができ、ユーザ認証の証明には ID トークンのみを使用できる。,2
V9,自己完結型トークン,V9.2,トークンコンテンツ,V9.2.3,サービスはそのサービス (オーディエンス) で使用することを意図したトークンのみを受け入れている。JWT では、これはサービス内で定義された許可リストに対して 'aud' クレーム を検証することで達成できる。,2
V9,自己完結型トークン,V9.2,トークンコンテンツ,V9.2.4,トークン発行者が同じ秘密鍵を使用して異なるオーディエンスにトークンを発行する場合、発行されるトークンには意図したオーディエンスを一意に識別するオーディエンス制限を含む。これにより、トークンが意図しないオーディエンスに再使用されることを防止している。オーディエンス識別子は動的にプロビジョンされる場合、トークン発行者はこれらのオーディエンスを検証して、オーディエンスのなりすましが発生しないようにする必要がある。,2
V10,OAuth と OIDC,V10.1,一般的な OAuth と OIDC セキュリティ,V10.1.1,トークンは厳密に必要とするコンポーネントにのみ送信される。たとえば、ブラウザベースの JavaScript アプリケーションで Backend for Frontend パターンを使用する場合、アクセストークンとリフレッシュトークンはバックエンドでのみアクセス可能である。,2
V10,OAuth と OIDC,V10.1,一般的な OAuth と OIDC セキュリティ,V10.1.2,クライアントは、認可サーバからの値 (認可コードや ID トークンなど) が、同じユーザエージェントセッションとトランザクションによって開始された認可フローから得られた値である場合にのみ、その値を受け入れている。これには、コード交換のための証明鍵 (PKCE) 'code_verifier'、'state'、OIDC 'nonce' など、クライアントが生成したシークレットが推測不可能であり、トランザクションに固有であり、トランザクションが開始されたクライアントとユーザエージェントセッションの両方に安全にバインドされていることが必要である。,2
V10,OAuth と OIDC,V10.2,OAuth クライアント,V10.2.1,コードフローが使用される場合、OAuth クライアントはコード交換のための証明鍵 (PKCE) 機能を使用するか、認可リクエストで送信された state パラメータをチェックすることで、トークンリクエストをトリガーする、一般にクロスサイトリクエストフォージェリ (CSRF) として知られるブラウザベースのリクエストフォージェリ攻撃から保護している。,2
V10,OAuth と OIDC,V10.2,OAuth クライアント,V10.2.2,OAuth クライアントが複数の認可サーバとやり取りできる場合、ミックスアップ攻撃に対して防御している。たとえば、認可サーバが 'iss' パラメータ値を返し、認可レスポンスとトークンレスポンスでそれを検証することを要求できる。,2
V10,OAuth と OIDC,V10.2,OAuth クライアント,V10.2.3,OAuth クライアントは、認可サーバへのリクエストで必要なスコープ (またはその他の認可パラメータ) のみをリクエストしている。,3
V10,OAuth と OIDC,V10.3,OAuth リソースサーバ,V10.3.1,リソースサーバは、そのサービス (オーディエンス) での使用を意図したアクセストークンのみを受け付けている。オーディエンスは、構造化されたアクセストークン (JWT の 'aud' クレームなど) に含めることや、トークンイントロスペクションエンドポイントを使用してチェックできる。,2
V10,OAuth と OIDC,V10.3,OAuth リソースサーバ,V10.3.2,"リソースサーバは、デリゲートされた認可を定義するアクセストークンからのクレームに基づいて認可決定を実施している。'sub', 'scope', 'authorization_details' などのクレームが存在する存在する場合、それらは決定の一部となる必要がある。",2
V10,OAuth と OIDC,V10.3,OAuth リソースサーバ,V10.3.3,アクセス制御の決定がアクセストークン (JWT または関連するトークンイントロスペクションレスポンス) から一意のユーザを識別する必要がある場合、リソースサーバは他のユーザーに再割り当てできないクレームからユーザを識別する。通常、これは 'iss' と 'sub' のクレームの組み合わせを使用することを意味する。,2
V10,OAuth と OIDC,V10.3,OAuth リソースサーバ,V10.3.4,"リソースサーバが特定の認証強度、認証方法、認証日時を要求する場合、リソースサーバは提示されたアクセストークンがこれらの制約を満たすことを検証している。たとえば、存在する場合、それぞれ OIDC 'acr', 'amr', 'auth_time' クレームを使用する。",2
V10,OAuth と OIDC,V10.3,OAuth リソースサーバ,V10.3.5,リソースサーバは、OAuth 2 の相互 TLS または OAuth 2 Demonstration of Proof of Possession (DPoP) のいずれかの送信者制約のあるアクセストークンを要求することで、盗まれたアクセストークンの使用やアクセストークンのリプレイを (認可されていない第三者から) 防止する。,3
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.1,認可サーバは、正確な文字列比較を使用して、事前登録された URI のクライアント固有の許可リストに基づいて、リダイレクト URI を検証している。,1
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.2,認可サーバが認可レスポンスで認可コードを返す場合、そのコードはトークンリクエストに対して一度のみ使用できる。アクセストークンの発行にすでに使用されている認可コードでの二回目の有効なリクエストに対しては、認可サーバはトークンリクエストを拒否して、認可コードに関連する発行済みトークンをすべて取り消す必要がある。,1
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.3,認可コードは有効期間を短くしている。最大有効期間は、L1 および L2 アプリケーションで 10 分まで、L3 アプリケーションで 1 分までである。,1
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.4,特定のクライアントに対して、認可サーバはこのクライアントが使用する必要があるグラントの使用のみを許可している。'token' (暗黙的フロー) と 'password' (リソースオーナーのパスワードクレデンシャルフロー) のグラントはもはや使用してはならないことに注意する。,1
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.5,認可サーバは、できれば送信者制約リフレッシュトークン、つまり、Demonstrating Proof of Possession (DPoP)、または相互 TLS (mTLS) を使用した Certificate-Bound Access Tokens を使用して、パブリッククライアントに対するリフレッシュトークンリプレイ攻撃を軽減している。L1 および L2 アプリケーションの場合、リフレッシュトークンローテーションを使用できる。リフレッシュトークンローテーションを使用する場合、認可サーバが使用後にリフレッシュトークンを無効化する必要があり、すでに使用されて無効化されたリフレッシュトークンが提供された場合には、その認可のためのすべてのリフレッシュトークンを失効している。,1
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.6,コードグラントを使用する場合、認可サーバはコード交換のための証明鍵 (PKCE) を要求することで認可コード傍受攻撃を軽減している。認可リクエストでは、認可サーバは有効な 'code_challenge' 値を要求する必要があり、'plain' の 'code_challenge_method' 値を受け入れてはいけない。トークンリクエストでは、'code_verifier' パラメータのバリデーションを要求する必要がある。,2
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.7,認可サーバが認可されていない動的クライアント登録をサポートしている場合、悪意のあるクライアントアプリケーションのリスクを緩和している。登録された URI などのクライアントメタデータを検証し、ユーザーの同意を確保し、信頼できないクライアントアプリケーションでの認可リクエストを処理する前にユーザに警告する必要がある。,2
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.8,リフレッシュトークンは、スライディングリフレッシュトークン有効期限が適用されている場合も含め、絶対的な有効期限を持つ。,2
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.9,悪意のあるクライアントや盗まれたトークンのリスクを軽減するために、認可されたユーザが認可サーバのユーザインタフェースを使用して、リフレッシュトークンとリファレンスアクセストークンを失効させることができる。,2
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.10,コンフィデンシャルクライアントは、トークンリクエスト、プッシュ認可リクエスト (PAR)、トークン失効リクエストなどのクライアントから認可済みサーバへのバックチャネルリクエストに対して認証されている。,2
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.11,認可サーバ設定では、必要なスコープのみを OAuth クライアントに割り当てている。,2
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.12,特定のクライアントに対して、認可サーバはこのクライアントが使用する必要がある 'response_mode' 値のみを許可している。たとえば、認可サーバがこの値を期待値と検証したり、プッシュ認可リクエスト (PAR) や JWT で保護された認可リクエスト (JAR) を使用している。,3
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.13,'code' グラントタイプは常にプッシュ認可リクエスト (PAR) と一緒に使用されている。,3
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.14,認可サーバは、相互 TLS (mTLS) を使用した証明書バインドアクセストークン、または DPoP バインドアクセストークン (Demonstration of Proof of Possession) のいずれかを使用して、送信者制約 (Proof-of-Possession) アクセストークンのみを発行する。,3
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.15,サーバサイドクライアント (エンドユーザデバイス上で実行されない) では、認可サーバは 'authorization_details' パラメータ値がクライアントバックエンドからのものであり、ユーザがそれを改竄していないことを確保している。たとえば、プッシュ認可リクエスト (PAR) または JWT で保護された認可リクエスト (JAR) の使用を要求する。,3
V10,OAuth と OIDC,V10.4,OAuth 認可サーバ,V10.4.16,"クライアントはコンフィデンシャルであり、認可サーバは相互 TLS ('tls_client_auth', 'self_signed_tls_client_auth') や秘密鍵 JWT ('private-key-jwt') などの強力なクライアント認証方法 (公開鍵暗号に基づき、リプレイ攻撃に耐性がある) の使用を要求する。",3
V10,OAuth と OIDC,V10.5,OIDC クライアント,V10.5.1,クライアント (依拠当事者) は ID トークンのリプレイ攻撃を軽減している。たとえば、ID トークンの 'nonce' クレームが OpenID プロバイダへの認証リクエスト (OAuth2 では認可サーバに送信される認可リクエストと呼ばれる) で送信された 'nonce' 値と一致することを確認している。,2
V10,OAuth と OIDC,V10.5,OIDC クライアント,V10.5.2,クライアントは ID トークンクレーム (通常は 'sub' クレーム) からユーザを一意に識別するが、(ID プロバイダのスコープでは) 他のユーザに再割り当てできない。,2
V10,OAuth と OIDC,V10.5,OIDC クライアント,V10.5.3,クライアントは悪意のある認可サーバが認可サーバメタデータを通じて別の認可サーバになりすまそうとする試みを拒否する。認可サーバメタデータの発行者 URL が、クライアントが期待する事前設定された発行者 URL と正確に一致しない場合、クライアントは認可サーバメタデータを拒否する必要がある。,2
V10,OAuth と OIDC,V10.5,OIDC クライアント,V10.5.4,クライアントは、トークンの 'aud' クレームがクライアントの 'client_id' 値と等しいことをチェックすることで、ID トークンがそのクライアント (オーディエンス) のために使用されることを意図していることを検証している。,2
V10,OAuth と OIDC,V10.5,OIDC クライアント,V10.5.5,OIDC バックチャネルログアウトを使用する場合、依拠当事者は強制ログアウトと、ログアウトフローにおける JWT 間の混乱によってサービス拒否を緩和している。クライアントは、ログアウトトークンが 'logout+jwt' の値で正しくタイプされていること、正しいメンバー名を持つ 'event' クレームを含むこと、'nonce' クレームを含まないことを検証する必要がある。有効期限を短く (例: 2 分) 設定することも推奨されることに注意する。,2
V10,OAuth と OIDC,V10.6,OpenID プロバイダ,V10.6.1,"OpenID プロバイダはレスポンスモードに 'code', 'ciba', 'id_token', 'id_token code' の値のみを許可している。'code' は 'id_token code' (OIDC ハイブリッドフロー) よりも優先されること、'token' (任意の暗黙的フロー) は使用してはならないことに注意する。",2
V10,OAuth と OIDC,V10.6,OpenID プロバイダ,V10.6.2,OpenID プロバイダは強制ログアウトによってサービス拒否を緩和している。エンドユーザから明示的な確認を得るか、'id_token_hint' などの (依拠当事者によって開始される) ログアウトリクエスト内のパラメータが存在する場合はそれを検証している。,2
V10,OAuth と OIDC,V10.7,同意管理,V10.7.1,認可サーバは、ユーザが各認可リクエストに同意することを確保している。クライアントのアイデンティティを保証できない場合、認可サーバは常に明示的にユーザに同意を求める必要がある。,2
V10,OAuth と OIDC,V10.7,同意管理,V10.7.2,認可サーバはユーザの同意を求める場合、同意される内容について十分かつ明確な情報を提示している。該当する場合、これにはリクエストされた認可の性質 (通常はスコープ、リソースサーバ、リッチ認可リクエスト (RAR) 認可の詳細に基づく)、認可されたアプリケーションのアイデンティティ、これらの認可の有効期間を含む。,2
V10,OAuth と OIDC,V10.7,同意管理,V10.7.3,ユーザは、認可サーバを通じてユーザが付与した同意を確認、変更、取消できる。,2
V11,暗号化,V11.1,暗号インベントリとドキュメント,V11.1.1,NIST SP 800-57 などの鍵管理標準に準拠した暗号鍵の管理と暗号鍵のライフサイクルに関するポリシーが文書化されている。これには鍵が過剰共有 (たとえば、共有シークレットでは二つより多いエンティティ、秘密鍵では一つより多いエンティティ) されないようにすることも含む必要がある。,2
V11,暗号化,V11.1,暗号インベントリとドキュメント,V11.1.2,暗号インベントリは、実行され、維持され、定期的に更新され、アプリケーションで使用されるすべての暗号鍵、アルゴリズム、証明書を含む。また、システム内で鍵を使用できる場所とできない場所、および鍵を使用して保護できるデータと保護できないデータの種類を文書化する必要がある。,2
V11,暗号化,V11.1,暗号インベントリとドキュメント,V11.1.3,暗号検出メカニズムが採用され、暗号化、ハッシュ化、署名操作など、システム内のすべての暗号インスタンスを識別している。,3
V11,暗号化,V11.1,暗号インベントリとドキュメント,V11.1.4,暗号インベントリが維持されている。これには、将来の脅威に対応するために、ポスト量子暗号などの新しい標準への移行パスを概説する、文書化された計画を含む必要がある。,3
V11,暗号化,V11.2,安全な暗号の実装,V11.2.1,暗号操作には業界で検証済みの実装 (ライブラリやハードウェアアクセラレーション実装を含む) が使用される。,2
V11,暗号化,V11.2,安全な暗号の実装,V11.2.2,アプリケーションは、乱数、認証された暗号化、MAC、ハッシュアルゴリズム、鍵長、ラウンド、暗号やモードをいつでも再構成、アップグレード、または交換できるように、暗号の敏捷性を考慮して設計され、暗号解読から保護している。同様に、鍵とパスワードを置換してデータを再暗号化することも可能である必要がある。これにより、承認済みポスト量子暗号 (PQC) スキームや標準の高保証実装が広く利用可能になると、PQC へのシームレスなアップグレードが可能になる。,2
V11,暗号化,V11.2,安全な暗号の実装,V11.2.3,すべての暗号プリミティブは、アルゴリズム、鍵サイズ、構成に基づいて、最低でも 128 ビットのセキュリティを利用している。たとえば、256 ビットの ECC 鍵はおよそ 128 ビットのセキュリティを提供するが、RSA では 128 ビットのセキュリティを実現するために 3072 ビットの鍵を必要とする。,2
V11,暗号化,V11.2,安全な暗号の実装,V11.2.4,情報の漏洩を防ぐために、比較、計算、リターンの際に「短絡」操作がなく、すべての暗号操作は一定時間となっている。,3
V11,暗号化,V11.2,安全な暗号の実装,V11.2.5,すべての暗号モジュールは失敗した場合の安全対策が施されており、パディングオラクル攻撃などの脆弱性を許さない方法でエラーが処理される。,3
V11,暗号化,V11.3,暗号アルゴリズム,V11.3.1,安全でないブロックモード (ECB など) や脆弱なパディングスキーム (PKCS#1 v1.5 など) を使用していない。,1
V11,暗号化,V11.3,暗号アルゴリズム,V11.3.2,AES with GCM などの承認済み暗号とモードのみを使用している。,1
V11,暗号化,V11.3,暗号アルゴリズム,V11.3.3,暗号化されたデータは、できれば承認済みで認証済みの暗号方式を使用するか、承認済み暗号方式と承認済み MAC アルゴリズムを組み合わせることによって、認可されていない改変から保護している。,2
V11,暗号化,V11.3,暗号アルゴリズム,V11.3.4,ナンス、初期化ベクトル、その他の使い捨て番号は複数の暗号鍵とデータ要素のペアに使用していない。生成手法は、使用されるアルゴリズムに適したものである必要がある。,3
V11,暗号化,V11.3,暗号アルゴリズム,V11.3.5,暗号アルゴリズムと MAC アルゴリズムの組み合わせは encrypt-then-MAC モードで動作している。,3
V11,暗号化,V11.4,ハッシュ化とハッシュベース関数,V11.4.1,デジタル署名、HMAC、KDF、ランダムビット生成など、一般的な暗号ユースケースには、承認済みハッシュ関数のみが使用されている。MD5 などの許可されていないハッシュ関数はいかなる暗号目的にも使用してはならない。,1
V11,暗号化,V11.4,ハッシュ化とハッシュベース関数,V11.4.2,パスワードは、現在のガイダンスに基づいて設定されたパラメータを用いた、承認済み計算集約型の鍵導出関数 (「パスワードハッシュ関数」とも呼ばれる) を使用して保存されている。この設定は、セキュリティとパフォーマンスのバランスをとり、必要なセキュリティレベルに対してブルートフォース攻撃を十分に困難にすべきである。,2
V11,暗号化,V11.4,ハッシュ化とハッシュベース関数,V11.4.3,データ認証やデータ完全性の一部としてデジタル署名に使用されるハッシュ関数は衝突耐性があり、適切なビット長を有している。衝突耐性が必要な場合、出力長は少なくとも 256 ビットである必要がある。第二原像攻撃攻撃への耐性のみが必要な場合、出力長は少なくとも 128 ビットである必要がある。,2
V11,暗号化,V11.4,ハッシュ化とハッシュベース関数,V11.4.4,アプリケーションは、パスワードから秘密鍵を導出する際に、鍵ストレッチパラメータを備えた承認済み鍵導出関数を使用している。使用するパラメータは、ブルートフォース攻撃によって生成された暗号鍵が侵害されることを防ぐために、セキュリティとパフォーマンスのバランスをとる必要がある。,2
V11,暗号化,V11.5,乱数値,V11.5.1,推測不可能であることを意図したすべての乱数と文字列は、暗号論的に安全な疑似乱数生成器 (CSPRNG) を使用して生成され、少なくとも 128 ビットのエントロピーを持つ必要がある。UUID はこの条件を満たさないことに注意する。,2
V11,暗号化,V11.5,乱数値,V11.5.2,使用されている乱数生成メカニズムは、負荷が高い場合でも安全に機能するように設計されている。,3
V11,暗号化,V11.6,公開鍵暗号,V11.6.1,鍵の生成とシード、およびデジタル署名の生成と検証には、承認済みの暗号アルゴリズムと動作モードのみが使用される。鍵生成アルゴリズムはフェルマー因数分解に対して脆弱な RSA 鍵など、既知の攻撃に対して脆弱な安全でない鍵を生成してはいけない。,2
V11,暗号化,V11.6,公開鍵暗号,V11.6.2,承認済み暗号アルゴリズム (Diffie-Hellman など) を鍵交換に使用し、鍵交換メカニズムが安全なパラメータを使用することに重点を置いている。これにより、Adversary-in-the-Middle 攻撃や暗号解読につながる可能性のある鍵確立プロセスへの攻撃を防ぐ。,3
V11,暗号化,V11.7,使用中のデータの暗号化,V11.7.1,フルメモリ暗号化を使用して、使用中の機密データを保護し、認可されていないユーザやプロセスによるアクセスを防いでいる。,3
V11,暗号化,V11.7,使用中のデータの暗号化,V11.7.2,データの最小化により、処理中に露出するデータの量を最小限に抑え、使用後すぐに、または可能な限り速やかにデータが暗号化されることを確保している。,3
V12,安全な通信,V12.1,一般的な TLS セキュリティガイダンス,V12.1.1,TLS 1.2 や TLS 1.3 など、最新の推奨バージョンの TLS プロトコルのみが有効である。最新バージョンの TLS プロトコルを優先オプションにする必要がある。,1
V12,安全な通信,V12.1,一般的な TLS セキュリティガイダンス,V12.1.2,推奨暗号スイートのみが有効であり、最も強力な暗号スイートが優先的に設定されている。L3 アプリケーションは前方秘匿性を提供する暗号スイートのみをサポートする必要がある。,2
V12,安全な通信,V12.1,一般的な TLS セキュリティガイダンス,V12.1.3,アプリケーションは、認証または認可に証明書 ID を使用する前に、mTLS クライアント証明書が信頼できることを検証している。,2
V12,安全な通信,V12.1,一般的な TLS セキュリティガイダンス,V12.1.4,Online Certificate Status Protocol (OCSP) Stapling などの証明書の失効を適切にチェックできる機能を設定し、有効にしている。,3
V12,安全な通信,V12.1,一般的な TLS セキュリティガイダンス,V12.1.5,アプリケーションの TLS 設定で Encrypted Client Hello (ECH) を有効にしており、TLS ハンドシェイクプロセス時に Server Name Indication (SNI) などの機密性の高いメタデータの開示を防いでいる。,3
V12,安全な通信,V12.2,外部向けサービスとの HTTPS 通信,V12.2.1,TLS がクライアントと外部向けの HTTP ベースのサービス間のすべての接続に使用されており、安全でない通信や非暗号化通信にフォールバックしない。,1
V12,安全な通信,V12.2,外部向けサービスとの HTTPS 通信,V12.2.2,外部向けサービスが公的に信頼できる TLS 証明書を使用している。,1
V12,安全な通信,V12.3,一般的なサービス間通信セキュリティ,V12.3.1,監視システム、管理ツール、リモートアクセス、SSH、ミドルウェア、データベース、メインフレーム、パートナーシステム、外部 API など、アプリケーションとのすべてのインバウンドおよびアウトバウンドの接続に、TLS などの暗号化プロトコルが使用されている。サーバは安全でないプロトコルや暗号化されていないプロトコルにフォールバックしてはいけない。,2
V12,安全な通信,V12.3,一般的なサービス間通信セキュリティ,V12.3.2,TLS クライアントは TLS サーバと通信する前に受信した証明書を検証している。,2
V12,安全な通信,V12.3,一般的なサービス間通信セキュリティ,V12.3.3,アプリケーション内の HTTP ベースの内部サービス間のすべての接続に TLS または別の適切なトランスポート暗号化メカニズムが使用されており、安全でない通信や暗号化されていない通信にフォールバックしていない。,2
V12,安全な通信,V12.3,一般的なサービス間通信セキュリティ,V12.3.4,内部サービス間の TLS 接続には信頼できる証明書が使用されている。内部で生成された証明書または自己署名証明書を使用する場合、受け側のサービスは特定の内部認証局や特定の自己署名証明書のみを信頼するように構成する必要がある。,2
V12,安全な通信,V12.3,一般的なサービス間通信セキュリティ,V12.3.5,システム内で通信するサービス (サービス内通信) は強力な認証を使用して、各エンドポイントが検証されていることを確保している。TLS クライアント認証などの強力な認証方式を採用し、公開鍵インフラストラクチャとリプレイ攻撃に耐性のあるメカニズムを使用して、アイデンティティを確認する必要がある。マイクロサービスアーキテクチャの場合は、サービスメッシュを使用して証明書管理を簡素化し、セキュリティを強化することを検討する。,3
V13,構成,V13.1,構成ドキュメント,V13.1.1,アプリケーションのすべての通信が文書化されている。これには、アプリケーションが依存する外部サービスや、アプリケーションが接続する外部ロケーションをエンドユーザが提供できる可能性がある場合を含む必要がある。,2
V13,構成,V13.1,構成ドキュメント,V13.1.2,アプリケーションが使用する各サービスについて、ドキュメントでは同時接続最大数 (接続プールの制限など) と、その制限に達した際のアプリケーションの動作 (フォールバックやリカバリのメカニズムを含む) を定義し、サービス拒否状態を防いでいる。,3
V13,構成,V13.1,構成ドキュメント,V13.1.3,アプリケーションドキュメントでは、使用するすべての外部システムやサービス (データベース、ファイルハンドル、スレッド、HTTP 接続) のリソース管理戦略を定義している。これには、リソース解放手順、タイムアウト設定、障害処理、再試行ロジックが実装されている場合、再試行制限、遅延、バックオフアルゴリズムの指定を含む。同期 HTTP リクエストレスポンス操作では、短いタイムアウトを義務付け、再試行を無効にするか、再試行回数を厳しく制限して、連鎖的な遅延やリソース枯渇を防ぐ必要がある。,3
V13,構成,V13.1,構成ドキュメント,V13.1.4,アプリケーションのドキュメントでは、組織の脅威モデルとビジネス要件に基づいて、アプリケーションのセキュリティにとって重要なシークレットとそれらを入れ替えるスケジュールを定義している。,3
V13,構成,V13.2,バックエンド通信構成,V13.2.1,API、ミドルウェア、データレイヤなど、アプリケーションの標準ユーザセッションメカニズムをサポートしていないバックエンドアプリケーションコンポーネント間の通信は認証されている。認証は、パスワード、API キー、特権アクセスを備えた共有アカウントなどの不変のクレデンシャルではなく、個別のサービスアカウント、短期トークン、証明書ベースの認証を使用する必要がある。,2
V13,構成,V13.2,バックエンド通信構成,V13.2.2,ローカルまたはオペレーティングシステムのサービス、API、ミドルウェア、データレイヤなどのバックエンドアプリケーションコンポーネント間の通信は最小限の権限が割り当てられたアカウントで実行されている。,2
V13,構成,V13.2,バックエンド通信構成,V13.2.3,サービス認証にクレデンシャルを使用する必要がある場合、コンシューマが使用するデフォルトクレデンシャル (root/root や admin/admin など) ではない。,2
V13,構成,V13.2,バックエンド通信構成,V13.2.4,許可リストを使用して、アプリケーションが通信 (アウトバウンドリクエスト、データロード、ファイルアクセスなど) を許可される外部のリソースやシステムを定義している。この許可リストは、アプリケーション層、Web サーバ、ファイアウォール、または複数の層の組み合わせで実装できる。,2
V13,構成,V13.2,バックエンド通信構成,V13.2.5,Web サーバまたはアプリケーションサーバはサーバがリクエストを送信したり、データやファイルをロードできるリソースやシステムの許可リストで構成されている。,2
V13,構成,V13.2,バックエンド通信構成,V13.2.6,アプリケーションが個別のサービスに接続する場合、最大並列接続数、最大許容接続数に達した際の動作、接続タイムアウト、再試行戦略など、各接続について文書化された構成に従っている。,3
V13,構成,V13.3,シークレット管理,V13.3.1,key vault などのシークレット管理ソリューションは、バックエンドシークレットを安全に作成、保管、アクセス制御、破棄するために使用している。これには、パスワード、鍵マテリアル、データベースやサードパーティシステムとの統合、時間ベースのトークンのための鍵やシード、その他の内部セキュリティ、API キーなどを含む。シークレットはアプリケーションのソースコードやビルド成果物に含めてはいけない。L3 アプリケーションでは、これには HSM などのハードウェア支援のソリューションを含む必要がある。,2
V13,構成,V13.3,シークレット管理,V13.3.2,シークレット資産へのアクセスは最小権限の原則に従っている。,2
V13,構成,V13.3,シークレット管理,V13.3.3,すべての暗号操作は、隔離されたセキュリティモジュール (vault やハードウェアセキュリティモジュールなど) を使用して実行され、鍵マテリアルがセキュリティモジュールの外部へ漏れないように安全に管理および保護している。,3
V13,構成,V13.3,シークレット管理,V13.3.4,シークレットはアプリケーションのドキュメントに基づいて有効期限が切れて入れ替えるように構成されている。,3
V13,構成,V13.4,意図しない情報漏洩,V13.4.1,アプリケーションは .git や .svn フォルダなどのソース管理メタデータなしでデプロイされるか、またはこれらのフォルダが外部からもアプリケーション自体からもアクセスできない方法でデプロイされる。,1
V13,構成,V13.4,意図しない情報漏洩,V13.4.2,デバッグ機能の露出や情報漏洩を防ぐため、本番環境ではすべてのコンポーネントでデバッグモードが無効になっている。,2
V13,構成,V13.4,意図しない情報漏洩,V13.4.3,Web サーバは、明示的に意図されていない限り、ディレクトリリストをクライアントに公開していない。,2
V13,構成,V13.4,意図しない情報漏洩,V13.4.4,潜在的な情報漏洩を避けるため、本番環境では HTTP TRACE メソッドの使用はサポートされない。,2
V13,構成,V13.4,意図しない情報漏洩,V13.4.5,ドキュメント (内部 API など) および監視エンドポイントは明示的に意図されない限り公開していない。,2
V13,構成,V13.4,意図しない情報漏洩,V13.4.6,アプリケーションはバックエンドコンポーネントの詳細なバージョン情報を公開していない。,3
V13,構成,V13.4,意図しない情報漏洩,V13.4.7,意図しない情報、構成、ソースコードの漏洩を防ぐために、Web 層が特定のファイル拡張子を持つファイルのみを処理するように構成されている。,3
V14,データ保護,V14.1,データ保護ドキュメント,V14.1.1,アプリケーションにより作成および処理されるすべての機密データが特定され、保護レベルに分類されている。これは Base64 や JWT 内のプレーンテキストペイロードなど、エンコードされているだけで簡単にデコードできるデータを含む。保護レベルでは、アプリケーションが準拠する必要のあるデータ保護やプライバシー規制を考慮する必要がある。,2
V14,データ保護,V14.1,データ保護ドキュメント,V14.1.2,文書化された保護要件一式がすべての機密データ保護レベルにある。これには一般的な暗号化、完全性検証、リテンション、データのログ記録方法、ログ内の機密データに関するアクセス制御、データベースレベルの暗号化、プライバシー、使用されるプライバシー強化技法に関連する要件、およびその他の機密性要件を含む必要がある (ただし、これらに限定されない)。,2
V14,データ保護,V14.2,一般的なデータ保護,V14.2.1,機密データが HTTP メッセージボディまたはヘッダフィールドでのみサーバに送信され、URL とクエリ文字列には API キーやセッショントークンなどの機密データが含まれない。,1
V14,データ保護,V14.2,一般的なデータ保護,V14.2.2,アプリケーションは機密データをロードバランサやアプリケーションキャッシュなどのサーバコンポーネントにキャッシュされないように防止している、もしくはデータを使用後に安全に削除している。,2
V14,データ保護,V14.2,一般的なデータ保護,V14.2.3,アプリケーションの制御外で望ましくないデータ収集を防ぐために、定義された機密データは信頼できないパーティ (ユーザトラッカーなど) には送信されない。,2
V14,データ保護,V14.2,一般的なデータ保護,V14.2.4,暗号化、完全性検証、保持、データのログ記録方法、ログ内の機密データへのアクセス制御、プライバシー、プライバシー強化テクノロジに関連する機密データに関するコントロールは、特定のデータの保護レベルに対するドキュメントで定義されているとおりに実装されている。,2
V14,データ保護,V14.2,一般的なデータ保護,V14.2.5,そのリソースの期待されるコンテンツタイプを持ち、機密性の高い動的コンテンツを含まないレスポンスのみをキャッシュするように、キャッシュメカニズムが設定されている。存在しないファイルがアクセスされる場合、Web サーバーは有効な別のファイルを返すのではなく 404 または 302 レスポンスを返す必要がある。これにより Web Cache Deception 攻撃を防ぐことができる。,3
V14,データ保護,V14.2,一般的なデータ保護,V14.2.6,アプリケーションは、アプリケーションの機能に必要な最小限の機密データのみを返している。たとえば、クレジットカード番号の一部の数字のみを返しており、番号全体は返していない。完全なデータが必要な場合は、ユーザが明示的に表示しない限り、ユーザインタフェースでマスクする必要がある。,3
V14,データ保護,V14.2,一般的なデータ保護,V14.2.7,機密情報はデータ保持分類の対象となり、古くなったデータや不要なデータは、定められたスケジュールに従って、または状況に応じて自動的に削除される。,3
V14,データ保護,V14.2,一般的なデータ保護,V14.2.8,ユーザーが保存に同意しない限り、ユーザーが送信したファイルのメタデータから機密情報が削除されている。,3
V14,データ保護,V14.3,クライアントサイドのデータ保護,V14.3.1,クライアントやセッションが終了した後、ブラウザ DOM などのクライアントストレージから認証データがクリアされる。'Clear-Site-Data' HTTP レスポンスヘッダフィールドで対応できるかもしれないが、セッションが終了した際にサーバ接続が利用できない場合にはクライアントサイドでもクリアできるようにする必要がある。,1
V14,データ保護,V14.3,クライアントサイドのデータ保護,V14.3.2,機密データがブラウザでキャッシュされないように、アプリケーションは十分なキャッシュ防止 HTTP レスポンスヘッダフィールド (つまり Cache-Control: no-store) を設定している。,2
V14,データ保護,V14.3,クライアントサイドのデータ保護,V14.3.3,ブラウザストレージ (localStorage、sessionStorage、IndexedDB、クッキーなど) に保存されるデータに、セッショントークンを除いて、機密データが含まれていない。,2
V15,セキュアコーディングとアーキテクチャ,V15.1,セキュアコーディングとアーキテクチャドキュメント,V15.1.1,アプリケーションドキュメントでは、脆弱性があるサードパーティコンポーネントのバージョンやライブラリ全般の更新について、リスクに基づく修復時間枠を定義して、これらのコンポーネントからのリスクを最小限に抑えている。,1
V15,セキュアコーディングとアーキテクチャ,V15.1,セキュアコーディングとアーキテクチャドキュメント,V15.1.2,使用しているすべてのサードパーティライブラリについて、ソフトウェア部品表 (SBOM) などのインベントリカテゴリを保守している。コンポーネントは事前定義済みで信頼でき、継続的に保守されているリポジトリから取得している。,2
V15,セキュアコーディングとアーキテクチャ,V15.1,セキュアコーディングとアーキテクチャドキュメント,V15.1.3,アプリケーションドキュメントでは、時間のかかる機能やリソースを必要とする機能を特定している。これには、この機能の過剰使用による可用性の損失を防ぐ方法や、レスポンスの構築にコンシューマのタイムアウトよりも長い時間がかかる状況を避ける方法を含む必要がある。可能性のある防御策としては、非同期処理、キューの使用、ユーザごとおよびアプリケーションごとの並列処理の制限などがある。,2
V15,セキュアコーディングとアーキテクチャ,V15.1,セキュアコーディングとアーキテクチャドキュメント,V15.1.4,アプリケーションドキュメントでは「リスクのあるコンポーネント」とみなされるサードパーティライブラリを強調している。,3
V15,セキュアコーディングとアーキテクチャ,V15.1,セキュアコーディングとアーキテクチャドキュメント,V15.1.5,アプリケーションドキュメントでは「危険な機能」が使用されているアプリケーションのパーツを強調している。,3
V15,セキュアコーディングとアーキテクチャ,V15.2,セキュリティアーキテクチャと依存関係,V15.2.1,アプリケーションは、文書化された更新および修復の時間枠に違反していないコンポーネントのみを含む。,1
V15,セキュアコーディングとアーキテクチャ,V15.2,セキュリティアーキテクチャと依存関係,V15.2.2,アプリケーションは、これに関する文書化されたセキュリティ上の決定と戦略に基づいて、時間のかかる機能やリソースを必要とする機能による可用性の損失に対する防御策を実装している。,2
V15,セキュアコーディングとアーキテクチャ,V15.2,セキュリティアーキテクチャと依存関係,V15.2.3,本番環境にはアプリケーションの機能に必要な機能のみを含み、テストコード、サンプルスニペット、開発機能などの不要な機能を公開していない。,2
V15,セキュアコーディングとアーキテクチャ,V15.2,セキュリティアーキテクチャと依存関係,V15.2.4,サードパーティコンポーネントとそのすべての推移的依存関係は、内部所有であるか外部ソースであるかに関わらず、想定されたリポジトリから組み込まれており、依存関係攪乱攻撃のリスクはない。,3
V15,セキュアコーディングとアーキテクチャ,V15.2,セキュリティアーキテクチャと依存関係,V15.2.5,アプリケーションは、「危険な機能」を含む、あるいは「リスクのあるコンポーネント」とみなされるサードパーティライブラリを使用していると文書化されているアプリケーションのパーツに対して、追加の保護を実装している。これは、サンドボックス化、カプセル化、コンテナ化、ネットワークレベルの分離などの技法を含み、アプリケーションの一部分を侵害した攻撃者がアプリケーションの他の部分に侵入するのを遅らせたり阻止する。,3
V15,セキュアコーディングとアーキテクチャ,V15.3,防御的コーディング,V15.3.1,アプリケーションはデータオブジェクトからフィールドの必要なサブセットのみを返す。たとえば、個別のフィールドの中にはユーザーがアクセスすべきではないものがあるため、データオブジェクト全体を返すべきではない。,1
V15,セキュアコーディングとアーキテクチャ,V15.3,防御的コーディング,V15.3.2,アプリケーションバックエンドが外部 URL を呼び出す場合、意図した機能でない限りリダイレクトに従わないように設定されている。,2
V15,セキュアコーディングとアーキテクチャ,V15.3,防御的コーディング,V15.3.3,アプリケーションには、コントローラやアクションごとに許可されるフィールドを制限することで、マスアサインメント攻撃から保護する対策がある。たとえば、そのアクションの一部となることを意図していないフィールド値を挿入または更新することはできない。,2
V15,セキュアコーディングとアーキテクチャ,V15.3,防御的コーディング,V15.3.4,すべてのプロキシとミドルウェアコンポーネントは、エンドユーザが操作できない信頼できるデータフィールドを使用してユーザのオリジナル IP アドレスを正しく転送し、アプリケーションと Web サーバは、動的 IP、VPN、企業のファームウェアによってオリジナル IP アドレスが信頼できない可能性があることを考慮して、ログ記録や、レート制限などのセキュリティ決定にこの正しい値を使用している。,2
V15,セキュアコーディングとアーキテクチャ,V15.3,防御的コーディング,V15.3.5,アプリケーションは変数が正しい型であることを明示的に保証し、厳密な等価演算と比較演算を実行している。これは、アプリケーションコードが変数の型について仮定することによって引き起こされる型ジャグリングや型コンフュージョンの脆弱性を回避するためである。,2
V15,セキュアコーディングとアーキテクチャ,V15.3,防御的コーディング,V15.3.6,JavaScript コードはオブジェクトリテラルの代わりに Set() や Map() を使用するなど、プロトタイプ汚染を防ぐ方法で記述している。,2
V15,セキュアコーディングとアーキテクチャ,V15.3,防御的コーディング,V15.3.7,アプリケーションが HTTP 変数汚染攻撃に対する防御策を備えている。特にアプリケーションフレームワークがリクエストパラメータのソース (クエリ文字列、ボディパラメータ、クッキー、ヘッダフィールド) を区別しない場合はこの防御が必要である。,2
V15,セキュアコーディングとアーキテクチャ,V15.4,安全な同時並行性,V15.4.1,マルチスレッドコード内の共有オブジェクト (キャッシュ、ファイル、複数のスレッドによってアクセスするメモリ内オブジェクトなど) は、スレッドセーフな型と、ロックやセマフォなどの同期メカニズムを使用して安全にアクセスして、競合状態やデータ破損を回避している。,3
V15,セキュアコーディングとアーキテクチャ,V15.4,安全な同時並行性,V15.4.2,リソースの存在やパーミッションなどのリソースの状態のチェックとそれらに依存するアクションは、単一のアトミック操作として実行され、チェック時間と使用時間 (TOCTOU) の競合状態を防いでいる。たとえば、ファイルを開く前にそのファイルが存在するかどうかをチェックしたり、ユーザのアクセスを付与する前に検証している。,3
V15,セキュアコーディングとアーキテクチャ,V15.4,安全な同時並行性,V15.4.3,ロックは一貫して使用され、互いに待機したり無限に再試行することによってスレッドがスタックすることを避けている。また、ロックロジックはリソースの管理を担当するコード内にとどめ、ロックが外部のクラスやコードによって不注意に、あるいは悪意を持って変更されないようにしている。,3
V15,セキュアコーディングとアーキテクチャ,V15.4,安全な同時並行性,V15.4.4,リソース割り当てのポリシーは、スレッドプールを活用するなどしてリソースへの公平なアクセスを確保し、優先度の低いスレッドが妥当な時間枠内で処理を進められるようにすることで、スレッドの枯渇を防いでいる。,3
V16,セキュリティログ記録とエラー処理,V16.1,セキュリティログ記録ドキュメント,V16.1.1,アプリケーションのテクノロジスタックの各レイヤで実行されるログ記録、ログ記録されるイベント、ログ形式、ログ記録の保存場所、ログ記録の使用方法、ログ記録へのアクセスコントロール方法、ログの保存期間を文書化したインベントリが存在している。,2
V16,セキュリティログ記録とエラー処理,V16.2,一般的なログ記録,V16.2.1,各ログエントリにはイベント発生時のタイムラインを詳細に調査するために必要なメタデータ (いつ、どこで、誰が、何を、など) を含んでいる。,2
V16,セキュリティログ記録とエラー処理,V16.2,一般的なログ記録,V16.2.2,すべてのログ記録コンポーネントのタイムソースが同期され、セキュリティイベントメタデータのタイムスタンプは UTC を使用するか、明示的なタイムゾーンオフセットを含む。分散システム間の一貫性を確保し、夏時間への移行時の混乱を防ぐため、UTC が推奨される。,2
V16,セキュリティログ記録とエラー処理,V16.2,一般的なログ記録,V16.2.3,アプリケーションはログインベントリに文書化されているファイルおよびサービスのログだけを保存またはブロードキャストしている。,2
V16,セキュリティログ記録とエラー処理,V16.2,一般的なログ記録,V16.2.4,ログは使用しているログプロセッサによって、できれば共通のログ形式を使用して、読み取りおよび関連付けできる。,2
V16,セキュリティログ記録とエラー処理,V16.2,一般的なログ記録,V16.2.5,機密データをログ記録する際、アプリケーションはデータの保護レベルに基づいてログ記録を実施している。たとえば、クレデンシャルや支払詳細など、特定のデータをログ記録することは許可できないことがある。セッショントークンなどのその他のデータは、ハッシュ化または、全体または一部がマスクすることによってのみログ記録できる。,2
V16,セキュリティログ記録とエラー処理,V16.3,セキュリティイベント,V16.3.1,すべての認証操作は成功した試行と失敗した試行を含めてログ記録されている。使用された認証の種類や要素などの追加のメタデータも収集する必要がある。,2
V16,セキュリティログ記録とエラー処理,V16.3,セキュリティイベント,V16.3.2,失敗した認可の試行をログ記録している。L3 では、これは、機密データへのアクセス時のログ記録 (機密データ自体はログ記録しない) を含む、すべての認可判定のログ記録を含む必要がある。,2
V16,セキュリティログ記録とエラー処理,V16.3,セキュリティイベント,V16.3.3,アプリケーションはドキュメントで定義されているセキュリティイベントをログ記録し、入力バリデーション、ビジネスロジック、アンチオートメーションなどのセキュリティ制御をバイパスする試みもログ記録している。,2
V16,セキュリティログ記録とエラー処理,V16.3,セキュリティイベント,V16.3.4,アプリケーションは、予期しないエラーや、バックエンド TLS 障害などのセキュリティ制御障害をログ記録している。,2
V16,セキュリティログ記録とエラー処理,V16.4,ログ保護,V16.4.1,ログインジェクションを防ぐためにすべてのログ記録コンポーネントがデータを適切にエンコードしている。,2
V16,セキュリティログ記録とエラー処理,V16.4,ログ保護,V16.4.2,ログは不正なアクセスから保護されており、改変できない。,2
V16,セキュリティログ記録とエラー処理,V16.4,ログ保護,V16.4.3,分析、検出、警告、エスカレーションのために、ログが論理的に分離されたシステムに安全に送信されている。これはアプリケーションが侵害されたとしても、ログが侵害されないことを保証することを目的としている。,2
V16,セキュリティログ記録とエラー処理,V16.5,エラー処理,V16.5.1,予期しないエラーやセキュリティ上重要なエラーが発生した際、スタックトレース、クエリ、秘密鍵、トークンなどの機密性の高い内部システムデータを開示しない、一般的なメッセージをコンシューマに返している。,2
V16,セキュリティログ記録とエラー処理,V16.5,エラー処理,V16.5.2,外部リソースへのアクセスが失敗した場合でも、たとえば、サーキットブレーカーやグレースフルデグラデーションなどのパターンを使用することで、アプリケーションは安全に動作し続ける。,2
V16,セキュリティログ記録とエラー処理,V16.5,エラー処理,V16.5.3,例外が発生した場合など、アプリケーションは適切かつ安全に失敗し、検証ロジックの結果としてのエラーにも関わらずトランザクションを処理するようなフェイルオープン状態を防いでいる。,2
V16,セキュリティログ記録とエラー処理,V16.5,エラー処理,V16.5.4,未処理の例外をすべてキャッチする「最終手段」のエラーハンドラが定義されている。これは、ログファイルに記録する必要があるエラー詳細を失わないようにするためであり、エラーがアプリケーションプロセス全体を停止して可用性が失われないようにするためである。,3
V17,WebRTC,V17.1,TURN サーバ,V17.1.1,Traversal Using Relays around NAT (TURN) サービスは特別な目的 (内部ネットワーク、ブロードキャスト、ループバックなど) のために予約されていない IP アドレスへのアクセスのみを許可している。これは IPv4 と IPv6 の両方のアドレスに適用することに注意する。,2
V17,WebRTC,V17.1,TURN サーバ,V17.1.2,正規のユーザが TURN サーバ上で多数のポートを開こうとした際に、Traversal Using Relays around NAT (TURN) サービスはリソース枯渇の影響を受けない。,3
V17,WebRTC,V17.2,メディア,V17.2.1,"データグラムトランスポート層セキュリティ (Datagram Transport Layer Security, DTLS) 証明書の鍵は、暗号鍵の管理に関する文書化されたポリシーに基づいて管理および保護されている。",2
V17,WebRTC,V17.2,メディア,V17.2.2,"メディアサーバは、承認されたデータグラムトランスポート層セキュリティ (Datagram Transport Layer Security, DTLS) 暗号スイートと、セキュアリアルタイムトランスポートプロトコル (Secure Real-time Transport Protocol) の鍵を確立するための DTLS 拡張 (DTLS-SRTP) 用の安全な保護プロファイルを使用およびサポートするように構成されている。",2
V17,WebRTC,V17.2,メディア,V17.2.3,"セキュアリアルタイムトランスポートプロトコル (Secure Real-time Transport Protocol, SRTP) 認証はメディアサーバで確認されており、リアルタイムトランスポートプロトコル (Real-time Transport Protocol, RTP) インジェクション攻撃によるサービス拒否状態や、メディアストリームへの音声または映像メディアの挿入を防止している。",2
V17,WebRTC,V17.2,メディア,V17.2.4,"不正なセキュアリアルタイムトランスポートプロトコル (Secure Real-time Transport Protocol, SRTP) パケットに遭遇した場合でも、メディアサーバは受信メディアトラフィックの処理を継続できる。",2
V17,WebRTC,V17.2,メディア,V17.2.5,"正規のユーザからセキュアリアルタイムトランスポートプロトコル (Secure Real-time Transport Protocol, SRTP) パケットが大量送信されている間も、メディアサーバは受信メディアトラフィックの処理を継続できる。",3
V17,WebRTC,V17.2,メディア,V17.2.6,"メディアサーバはデータグラムトランスポート層セキュリティ (Datagram Transport Layer Security, DTLS) での ""ClientHello"" Race Condition 脆弱性の影響を受けておらず、メディアサーバが脆弱性を持つことを公表しているかどうかを確認し、競合状態テストを実行している。",3
V17,WebRTC,V17.2,メディア,V17.2.7,"正規のユーザからセキュアリアルタイムトランスポートプロトコル (Secure Real-time Transport Protocol, SRTP) パケットが大量送信されている間も、メディアサーバに関連付けられた音声や映像のレコーディングメカニズムは受信メディアトラフィックの処理を継続できる。",3
V17,WebRTC,V17.2,メディア,V17.2.8,"データグラムトランスポート層セキュリティ (Datagram Transport Layer Security, DTLS) 証明書はセキュアリアルタイムトランスポートプロトコル (Secure Real-time Transport Protocol, SRTP) フィンガープリント属性と照合され、チェックに失敗した場合はメディアストリームを終了して、メディアストリームの真正性を確保している。",3
V17,WebRTC,V17.3,シグナリング,V17.3.1,フラッド攻撃中でも、シグナリングサーバは正当な受信シグナリングメッセージの処理を継続できる。これはシグナリングレベルでレート制限を実装することで実現できる。,2
V17,WebRTC,V17.3,シグナリング,V17.3.2,サービス拒否状態を引き起こす可能性のある不正なシグナリングメッセージに遭遇した場合でも、シグナリングサーバは正当なシグナリングメッセージの処理を継続できる。これには、入力バリデーションの実装、整数オーバーフローの安全な処理、バッファオーバーフローの防止、その他の堅牢なエラー処理技法の採用などを含む。,2

